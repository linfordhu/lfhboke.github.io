<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>lfh&#39;s bokes</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="lfh&#39;s bokes">
<meta property="og:url" content="https://linfordhu.github.io/lfhboke.github.io/page/4/index.html">
<meta property="og:site_name" content="lfh&#39;s bokes">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lfh&#39;s bokes">
  
    <link rel="alternate" href="/lfhboke.github.io/atom.xml" title="lfh&#39;s bokes" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/lfhboke.github.io/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/lfhboke.github.io/" id="logo">lfh&#39;s bokes</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/lfhboke.github.io/">Home</a>
        
          <a class="main-nav-link" href="/lfhboke.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/lfhboke.github.io/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://linfordhu.github.io/lfhboke.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-activeMq基础应用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2017/06/17/activeMq基础应用/" class="article-date">
  <time datetime="2017-06-17T11:44:09.000Z" itemprop="datePublished">2017-06-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2017/06/17/activeMq基础应用/">消息中间件之ActiveMq（基础篇）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>activeMq是一种消息中间件，鉴于没有介绍过中间件，先从中间件概念介绍。</p>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><h4 id="什么是中间件？"><a href="#什么是中间件？" class="headerlink" title="什么是中间件？"></a>什么是中间件？</h4><p>在合并、添加服务或者扩展可用服务之后，需要集成新组件或者尽可能高效地扩展现有组件。要集成异类组件，最方便的方法不是将它们重新创建为同类元素，而是提供一个允许它们进行通信的层。该层被称作为中间件。</p>
<p><div id="flowchart-0" class="flow-chart"></div></p>
<h4 id="中间件的分类"><a href="#中间件的分类" class="headerlink" title="中间件的分类"></a>中间件的分类</h4><p>. 基于远程过程调用的中间件。</p>
<p>. 基于对象请求代理的中间件。</p>
<p>. 基于消息的中间件或基于MOM的中间件</p>
<p>activeMq就是一种经典的消息中间件。</p>
<h3 id="消息中间件（Message-Oriented-Middleware-MOM-）"><a href="#消息中间件（Message-Oriented-Middleware-MOM-）" class="headerlink" title="消息中间件（Message-Oriented Middleware(MOM)）"></a>消息中间件（Message-Oriented Middleware(MOM)）</h3><h4 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h4><p>消息队列中间件是分布式系统中重要的组件，主要解决应用耦合、异步消息、流量削峰等问题。实现高性能、高可用、可伸缩和最终一致性架构。是大型分布式系统不可缺少的中间件。</p>
<h4 id="消息中间件的结构"><a href="#消息中间件的结构" class="headerlink" title="消息中间件的结构"></a>消息中间件的结构</h4><p><div id="flowchart-1" class="flow-chart"></div></p>
<h3 id="JMS-Java-Message-Service"><a href="#JMS-Java-Message-Service" class="headerlink" title="JMS(Java Message Service)"></a>JMS(Java Message Service)</h3><p>activeMq是基于JMS而实现的消息中间件。</p>
<h4 id="什么是jms？"><a href="#什么是jms？" class="headerlink" title="什么是jms？"></a>什么是jms？</h4><p>JMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或者分布式系统中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。</p>
<h4 id="JMS消息传送模式"><a href="#JMS消息传送模式" class="headerlink" title="JMS消息传送模式"></a>JMS消息传送模式</h4><h5 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h5><p>客户端使用此模式向队列目的地发送一条消息，只有一个接收者能够从该目的地获得消息。访问该目的地的其他任何接收者都不能获得该消息。</p>
<p><div id="flowchart-2" class="flow-chart"></div></p>
<h5 id="publish-subscribe"><a href="#publish-subscribe" class="headerlink" title="publish-subscribe"></a>publish-subscribe</h5><p>客户端使用发布/订阅模式。客户端使用此广播模式向主题目的地发送一条消息，任意数量的使用方订户都可以从该目的地检索此消息。每个订户都获得此消息的一个副本。</p>
<p><div id="flowchart-3" class="flow-chart"></div><br>见谅，hexo的markdown的流程图多路输出貌似有点问题，只能线用condition节点标识代替多路，请不用看yes，和no提示。</p>
<h3 id="JMS实现——ActiveMQ"><a href="#JMS实现——ActiveMQ" class="headerlink" title="JMS实现——ActiveMQ"></a>JMS实现——ActiveMQ</h3><p>介绍了那么多概念，现在介绍ActiveMQ。</p>
<p>摘录百度百科的概念解释：</p>
<p>ActiveMQ是Apache软件基金下的一个开源软件，它遵循JMS1.1规范，是消息驱动中间件软件。它为企业消息传递提供高可用，出色性能，可扩展，稳定和安全保障。</p>
<p><font color="red">既然遵循JMS规范，则可以说ActiveMQ是JMS的一种实现系统。</font>所以ActiveMQ也实现了两种消息传递模式，P2P以及Pub/Sub。</p>
<h4 id="ActiveMQ简单案例"><a href="#ActiveMQ简单案例" class="headerlink" title="ActiveMQ简单案例"></a>ActiveMQ简单案例</h4><p>消费生产者：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建session</span></span><br><span class="line">ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">"tcp://127.0.0.1:61616"</span>);</span><br><span class="line">Connection connection = connectionFactory.createConnection();</span><br><span class="line">connection.start();</span><br><span class="line">Session session = connection.createSession(<span class="keyword">true</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"><span class="comment">//创建一个消息队列</span></span><br><span class="line">Destination destination = session.createQueue(<span class="string">"test.topic"</span>);</span><br><span class="line"><span class="comment">//创建消息生产者</span></span><br><span class="line">MessageProducer producer = session.createProducer(destination);</span><br><span class="line"><span class="comment">//消息持久化</span></span><br><span class="line">producer.setDeliveryMode(DeliveryMode.PERSISTENT);</span><br><span class="line">producer.send(session.createTextMessage(<span class="string">"Message producer"</span>));</span><br><span class="line"><span class="comment">//提交会话</span></span><br><span class="line">session.commit();</span><br></pre></td></tr></table></figure></p>
<p>消息消费者</p>
<p><code>`</code>java<br>//创建会话(与生产者一样)</p>
<p>……</p>
<p>//获取消费者<br>Destination destination = session.createQueue(“test.topic”);<br>//创建消费者<br>MessageConsumer consumer = session.createConsumer(destination);<br>while(true) {<br>    TextMessage message = (TextMessage) consumer.receive();<br>    if(message!=null) {<br>        System.out.println(“Message Consumer:” + message.getText());<br>    } else {<br>        break;<br>    }<br>}<br>session.commit();</p>
<p><code>`</code><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">op1=>operation: 应用
op2=>operation: 中间件
op3=>operation: 硬件操作系统

op1(right)->op2(right)->op3(right)</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><textarea id="flowchart-1-code" style="display: none">op1=>operation: RPC系统
op2=>operation: Msg1
op4=>operation: Msg1
op5=>operation: MOM系统
op6=>operation: RPC系统

op1(right)->op2(right)->op5(right)->op4(right)->op6(right)</textarea><textarea id="flowchart-1-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-1", options);</script><textarea id="flowchart-2-code" style="display: none">op1=>operation: 客户端A
op2=>operation: Msg2
op3=>operation: Msg1
op4=>operation: 队列
op5=>operation: Msg2
op6=>operation: 客户端D

op1(right)->op2(right)->op3(right)->op4(right)->op5(right)->op6(right)</textarea><textarea id="flowchart-2-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-2-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-2-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-2", options);</script><textarea id="flowchart-3-code" style="display: none">op1=>operation: 客户端A
op2=>operation: Msg3
con3=>condition: 主题
op3=>operation: 客户端B
op4=>operation: 客户端C
op5=>operation: Msg3
op6=>operation: Msg3

op1(right)->op2(right)->con3
con3(yes,up)->op5(right)->op3
con3(no,down)->op6(right)->op4</textarea><textarea id="flowchart-3-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-3-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-3-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-3", options);</script></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2017/06/17/activeMq基础应用/" data-id="cjyms8jsd000edwudy7opwq7k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-springmvc组件之HandlerMapping" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2017/04/30/springmvc组件之HandlerMapping/" class="article-date">
  <time datetime="2017-04-30T10:16:23.000Z" itemprop="datePublished">2017-04-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2017/04/30/springmvc组件之HandlerMapping/">springmvc组件之HandlerMapping</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>用了很多关于Controller，最近一次面试被问SpringMvc的组件有哪些，有点懵逼？</p>
<h3 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h3><p>其作用是：通过getHandler来获取请求的Handler和Interceptors。它在DispatcherServlet.initHandlerMappings(context)中被初始化。默认使用为：<font color="red">BeanNameUrlHandlerMapping和DefaultAnnotationHandlerMapping。</font></p>
<h4 id="HandlerMapping类图"><a href="#HandlerMapping类图" class="headerlink" title="HandlerMapping类图"></a>HandlerMapping类图</h4><p><img src="/lfhboke.github.io/css/images/handlermapping.png" alt="HandlerMapping类图"><br>HandlerMapping所有的实现类都继承了一个共有的抽象类AbstractHandlerMapping，它所有的子类中分类如下几只：</p>
<ol>
<li><font color="red">EmptyHandlerMapping:</font>空处理，直接返回空</li>
<li><font color="red">AbstractHandlerMethodMapping：</font>通过method处理</li>
<li><font color="red">AbstractUrlHandlerMapping:</font>通过url处理<h4 id="AbstractHandlerMapping"><a href="#AbstractHandlerMapping" class="headerlink" title="AbstractHandlerMapping"></a>AbstractHandlerMapping</h4>AbstractHandlerMapping是HandlerMapping的抽象实现，所有的HandlerMapping的实现类都继承自AbstractHandlerMapping。AbstractHandlerMapping采用模板模式设计了HandlerMapping实现的整体架构，子类只需要通过模板方法提供一些初始值或具体的算法即可。</li>
</ol>
<p>HandlerMapping的作用是根据request找到Handler和Interceptors。</p>
<ol>
<li>获取Handler的过程通过模板方法getHandlerInternal交给了子类。</li>
<li>Abstract Handler Mapping保存了所用配置的Inteceptor，在获取Handler后自己根据从request提取的lookupPath将相应的Interceptors装配上去，当然子类也可以通过getHandlerInternal设置自己的Interceptor。<h4 id="创建AbstractHandlerMapping"><a href="#创建AbstractHandlerMapping" class="headerlink" title="创建AbstractHandlerMapping"></a>创建AbstractHandlerMapping</h4>AbstractHandlerMapping继承了webApplicationObjectSupport，初始化时会自动调用模板方法initApplicationContext，AbstractHandlerMapping的创建就是在initApplicationContext()方法里实现的。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.springframework.web.servlet.handler.AbstractHandlerMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHandlerMapping</span> <span class="keyword">extends</span> <span class="title">WebApplicationObjectSupport</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">HandlerMapping</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 用于配置SpringMVC的拦截器，有两种方式配置：</span></span><br><span class="line"><span class="comment">		 * - 注册HandlerMapping时通过属性设置。</span></span><br><span class="line"><span class="comment">		 * - 通过子类的extendInterceptors模板方法设置。</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * interceptors并不会直接使用，而是通过initInterceptors()分配到mappedInterceptors 或者 adaptedInterceptors中进行使用。</span></span><br><span class="line"><span class="comment">		**/</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局拦截器：无需匹配url</span></span><br><span class="line">    	<span class="keyword">private</span> <span class="keyword">final</span> List&lt;HandlerInterceptor&gt; adaptedInterceptors = <span class="keyword">new</span> ArrayList&lt;HandlerInterceptor&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//path拦截器: 通过匹配url拦截</span></span><br><span class="line">    	<span class="keyword">private</span> <span class="keyword">final</span> List&lt;MappedInterceptor&gt; mappedInterceptors = <span class="keyword">new</span> ArrayList&lt;MappedInterceptor&gt;();</span><br><span class="line">    	</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">    	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationContext</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    	    <span class="comment">//模板方法，供子类实现： 用于给子类提供一个添加(修改)interceptors的入口，现有SpringMVC 没有实现。</span></span><br><span class="line">    		extendInterceptors(<span class="keyword">this</span>.interceptors);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//初始化mappedInterceptors</span></span><br><span class="line">    		detectMappedInterceptors(<span class="keyword">this</span>.mappedInterceptors);</span><br><span class="line">			</span><br><span class="line">		<span class="comment">//初始化Interceptor:  分配interceptors </span></span><br><span class="line">    		initInterceptors();</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//将SpringMVC容器以及父容器中所有的MappedInterceptor类型的Bean添加到mappedInterceptors</span></span><br><span class="line">    	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">detectMappedInterceptors</span><span class="params">(List&lt;MappedInterceptor&gt; mappedInterceptors)</span> </span>&#123;</span><br><span class="line">            mappedInterceptors.addAll(</span><br><span class="line">                    BeanFactoryUtils.beansOfTypeIncludingAncestors(</span><br><span class="line">                            getApplicationContext(),MappedInterceptor.class, <span class="keyword">true</span>, <span class="keyword">false</span>).values());</span><br><span class="line">        &#125;	</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//将interceptors中各对象类型添加至 mappedInterceptors 或者 adaptedInterceptors</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInterceptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.interceptors.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.interceptors.size(); i++) &#123;</span><br><span class="line">                    Object interceptor = <span class="keyword">this</span>.interceptors.get(i);</span><br><span class="line">                    <span class="keyword">if</span> (interceptor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Entry number "</span> + i + <span class="string">" in interceptors array is null"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (interceptor <span class="keyword">instanceof</span> MappedInterceptor) &#123;</span><br><span class="line">                        mappedInterceptors.add((MappedInterceptor) interceptor);</span><br><span class="line">                    &#125;    <span class="keyword">else</span> &#123;</span><br><span class="line">                        adaptedInterceptors.add(adaptInterceptor(interceptor));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="AbstractHandlerMapping作用"><a href="#AbstractHandlerMapping作用" class="headerlink" title="AbstractHandlerMapping作用"></a>AbstractHandlerMapping作用</h4><p>HandlerMapping是通过getHandler来获取请求的Handler和Interceptors。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.springframework.web.servlet.handler.AbstractHandlerMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">//模板方法，由子类实现</span></span><br><span class="line">    Object handler = getHandlerInternal(request);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handler = getDefaultHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Bean name or resolved handler?</span></span><br><span class="line">    <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String handlerName = (String) handler;</span><br><span class="line">        handler = getApplicationContext().getBean(handlerName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getHandlerExecutionChain(handler, request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>getHandler方法的实现分为两部分：找Handler和getHandlerExecutionChain添加拦截器。</p>
<p>找Handler的过程：</p>
<ol>
<li>通过getHandlerInternal()模板方法获取，此方法由子类实现。</li>
<li>如果没有获取到则使用默认的Handler，可以在配置HandlerMapping时通过defaultHandler属性配置。</li>
<li>如果找到的Handler是String类型，则从SpringMVC容器里找到该名称的Bean。</li>
</ol>
<p>getHandlerExecutionChain<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandlerExecutionChain</span><span class="params">(Object handler, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    HandlerExecutionChain chain = </span><br><span class="line">        (handler <span class="keyword">instanceof</span> HandlerExecutionChain) ?</span><br><span class="line">            (HandlerExecutionChain) handler : <span class="keyword">new</span> HandlerExecutionChain(handler);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//添加全局inteceptors        </span></span><br><span class="line">    chain.addInterceptors(getAdaptedInterceptors());</span><br><span class="line">    </span><br><span class="line">    String lookupPath = urlPathHelper.getLookupPathForRequest(request);</span><br><span class="line">    <span class="keyword">for</span> (MappedInterceptor mappedInterceptor : mappedInterceptors) &#123;</span><br><span class="line">         <span class="comment">//根据url 匹配寻找 MappedInterceptor</span></span><br><span class="line">        <span class="keyword">if</span> (mappedInterceptor.matches(lookupPath, pathMatcher)) &#123;</span><br><span class="line">            chain.addInterceptor(mappedInterceptor.getInterceptor());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>getHandlerExecutionChain方法比较简单：首先是使用handler创建HandlerExecutionChain，然后将adaptedInterceptors和request匹配的mappedInterceptors添加进去即可。</p>
<h4 id="AbstractUrlHandlerMapping系列"><a href="#AbstractUrlHandlerMapping系列" class="headerlink" title="AbstractUrlHandlerMapping系列"></a>AbstractUrlHandlerMapping系列</h4><font color="red">AbstractUrlHandlerMapping</font>从名称就可以看出它是通过url来进行匹配的。它工作的大致原理：将url与对应的Handler保存在一个Map中，在它的getHandlerInternal方法中，使用url从Map中获取Handler。<br>1. AbstractUrlHandlerMapping实现了根据url从Map获取Handler的逻辑，Map的初始化工作则交给了子孙类中实现。<br>2. AbstractUrlHandlerMapping还定义了”/“请求处理器rootHandler<br><br>Handler方法的入口是<font color="red">getHandlerInternal</font>，通过这个方法，查看下Map是如何初始化的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.springframework.web.servlet.handler.AbstractUrlHandlerMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractUrlHandlerMapping</span> <span class="keyword">extends</span> <span class="title">AbstractHandlerMapping</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object rootHandler;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; handlerMap = <span class="keyword">new</span> LinkedHashMap&lt;String, Object&gt;();</span><br><span class="line">    </span><br><span class="line">   	<span class="meta">@Override</span></span><br><span class="line">   	<span class="function"><span class="keyword">protected</span> Object <span class="title">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   	    <span class="comment">//获取request的请求url</span></span><br><span class="line">   		String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);</span><br><span class="line">   		</span><br><span class="line">   		<span class="comment">//注1. 从Map中查找匹配的Handler</span></span><br><span class="line">   		Object handler = lookupHandler(lookupPath, request);</span><br><span class="line">   		<span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">   			Object rawHandler = <span class="keyword">null</span>;</span><br><span class="line">   			<span class="keyword">if</span> (<span class="string">"/"</span>.equals(lookupPath)) &#123;</span><br><span class="line">   				rawHandler = getRootHandler();</span><br><span class="line">   			&#125;</span><br><span class="line">   			<span class="keyword">if</span> (rawHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">   				rawHandler = getDefaultHandler();</span><br><span class="line">   			&#125;</span><br><span class="line">   			<span class="keyword">if</span> (rawHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">   				<span class="comment">// 如果handler是String,则到容器找到对应的bean.</span></span><br><span class="line">   				<span class="keyword">if</span> (rawHandler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">   					String handlerName = (String) rawHandler;</span><br><span class="line">   					rawHandler = getApplicationContext().getBean(handlerName);</span><br><span class="line">   				&#125;</span><br><span class="line">   				</span><br><span class="line">   				<span class="comment">//校验handler与request是否匹配，模板方法由子类实现。（已知的子类中都没有实现）</span></span><br><span class="line">   				validateHandler(rawHandler, request);</span><br><span class="line">   				</span><br><span class="line">   				<span class="comment">//注2. </span></span><br><span class="line">   				handler = buildPathExposingHandler(rawHandler, lookupPath, lookupPath, <span class="keyword">null</span>);</span><br><span class="line">   			&#125;</span><br><span class="line">   		&#125;</span><br><span class="line">   	       </span><br><span class="line">   	     <span class="comment">//log 略.....</span></span><br><span class="line">   		<span class="keyword">return</span> handler;</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>lookupHandler<br><font color="red">lookupHandler</font>方法用于使用lookupPath从Map中找到匹配的Handler，不过很多时候并不能直接从Map中get到，因为很多Handler都用了Pattern模式，如<font color="red">“/user/*”</font>。<br>1. 无法直接从Map中get到对应的Handler<br>2. 同一个url可能会匹配到多个Handler<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.springframework.web.servlet.handler.AbstractUrlHandlerMapping</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">lookupHandler</span><span class="params">(String urlPath, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 从map中获取,判断是否直接全字匹配。</span></span><br><span class="line">		Object handler = <span class="keyword">this</span>.handlerMap.get(urlPath);</span><br><span class="line">		<span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 如果为String,则从容器中获取bean</span></span><br><span class="line">			<span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">				String handlerName = (String) handler;</span><br><span class="line">				handler = getApplicationContext().getBean(handlerName);</span><br><span class="line">			&#125;</span><br><span class="line">			validateHandler(handler, request);</span><br><span class="line">			<span class="keyword">return</span> buildPathExposingHandler(handler, urlPath, urlPath, <span class="keyword">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Pattern 匹配</span></span><br><span class="line">		List&lt;String&gt; matchingPatterns = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		<span class="keyword">for</span> (String registeredPattern : <span class="keyword">this</span>.handlerMap.keySet()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (getPathMatcher().match(registeredPattern, urlPath)) &#123;</span><br><span class="line">			    <span class="comment">//记录匹配到的 patterns</span></span><br><span class="line">				matchingPatterns.add(registeredPattern);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		String bestPatternMatch = <span class="keyword">null</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//自定义Comparator ,按照规则对匹配到的patterns进行匹配：： Comparatorg根据 *，以及&#123; 个数来判断优先级.</span></span><br><span class="line">		Comparator&lt;String&gt; patternComparator = getPathMatcher().getPatternComparator(urlPath);</span><br><span class="line">		<span class="keyword">if</span> (!matchingPatterns.isEmpty()) &#123;</span><br><span class="line">			Collections.sort(matchingPatterns, patternComparator);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//获取bestPatternMatch</span></span><br><span class="line">			bestPatternMatch = matchingPatterns.get(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (bestPatternMatch != <span class="keyword">null</span>) &#123;</span><br><span class="line">			handler = <span class="keyword">this</span>.handlerMap.get(bestPatternMatch);</span><br><span class="line">			<span class="comment">// 如果为String,则从容器中获取bean</span></span><br><span class="line">			<span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">				String handlerName = (String) handler;</span><br><span class="line">				handler = getApplicationContext().getBean(handlerName);</span><br><span class="line">			&#125;</span><br><span class="line">			validateHandler(handler, request);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 获取pattern通配符即* 匹配的部分</span></span><br><span class="line"><span class="comment">			 * matcher.extractPathWithinPattern("/*/</span>*<span class="string">", "</span>/user/add<span class="string">");  //结果： user/add</span></span><br><span class="line"><span class="string">			 * matcher.extractPathWithinPattern("</span>/user<span class="comment">/*", "/user/add");  //结果： add</span></span><br><span class="line"><span class="comment">			 * matcher.extractPathWithinPattern("/*/</span>add<span class="string">", "</span>/user/add<span class="string">");  //结果： user</span></span><br><span class="line"><span class="string">			 */</span></span><br><span class="line"><span class="string">			String pathWithinMapping = getPathMatcher().extractPathWithinPattern(bestPatternMatch, urlPath);</span></span><br><span class="line"><span class="string">			</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			//matchingPatterns中可能有多个 同 bestPatternMatch 优先级相同的 patterns, 将所有同级别的pattern记录</span></span><br><span class="line"><span class="string">			Map&lt;String, String&gt; uriTemplateVariables = new LinkedHashMap&lt;String, String&gt;();</span></span><br><span class="line"><span class="string">			for (String matchingPattern : matchingPatterns) &#123;</span></span><br><span class="line"><span class="string">			    //通过compare ==0 ，说明matchingPattern与bestPatternMatch 优先级相同</span></span><br><span class="line"><span class="string">				if (patternComparator.compare(bestPatternMatch, matchingPattern) == 0) &#123;</span></span><br><span class="line"><span class="string">				    /**</span></span><br><span class="line"><span class="string">				     * getPathMatcher().extractUriTemplateVariables(matchingPattern, urlPath)伪码表示：</span></span><br><span class="line"><span class="string">				     *  判断urlPath与matchingPattern是否匹配，</span></span><br><span class="line"><span class="string">				     *  如果匹配：则返回一个LinkedHashMap&lt;String, String&gt;().of(urlPath,matchingPattern);</span></span><br><span class="line"><span class="string">				     *  否则：返回一个 LinkedHashMap.empty();</span></span><br><span class="line"><span class="string">				     */</span></span><br><span class="line"><span class="string">					uriTemplateVariables.putAll(getPathMatcher().extractUriTemplateVariables(matchingPattern, urlPath));</span></span><br><span class="line"><span class="string">				&#125;</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">			return buildPathExposingHandler(handler, bestPatternMatch, pathWithinMapping, uriTemplateVariables);</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		// No handler found...</span></span><br><span class="line"><span class="string">		return null;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br></pre></td></tr></table></figure><br><br>buildPathExposingHandler<br><br><font color="red">buildPathExposingHandler</font>方法用于给查找到的handler注册两个内部拦截器<font color="red">PathExposingHandlerInterceptor和UriTemplateVariablesHandlerInterceptor</font>，主要的作用是将与当前url实际匹配的pattern、匹配条件和url等参数设置到request的属性里，这样在后续的处理过程中就可以从request属性中获取，无需再查找一遍。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.springframework.web.servlet.handler.AbstractUrlHandlerMapping $ PathExposingHandlerInterceptor</span></span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PathExposingHandlerInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String bestMatchingPattern;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String pathWithinMapping;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">PathExposingHandlerInterceptor</span><span class="params">(String bestMatchingPattern, String pathWithinMapping)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.bestMatchingPattern = bestMatchingPattern;</span><br><span class="line">		<span class="keyword">this</span>.pathWithinMapping = pathWithinMapping;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> </span>&#123;</span><br><span class="line">		exposePathWithinMapping(<span class="keyword">this</span>.bestMatchingPattern, <span class="keyword">this</span>.pathWithinMapping, request);</span><br><span class="line">		request.setAttribute(HandlerMapping.INTROSPECT_TYPE_LEVEL_MAPPING, supportsTypeLevelMappings());</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>Map初始化<br><br>Map的初始化工作是由<font color="red">registerHandler</font>方法进行的，与之前不同的是，该方法是由子类调用的。该方法代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.springframework.web.servlet.handler.AbstractUrlHandlerMapping</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerHandler</span><span class="params">(String[] urlPaths, String beanName)</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String urlPath : urlPaths) &#123;</span><br><span class="line">        registerHandler(urlPath, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerHandler</span><span class="params">(String urlPath, Object handler)</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">		Object resolvedHandler = handler;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果没有设置lazyInitHandlers ，且handler是string</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.lazyInitHandlers &amp;&amp; handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">			String handlerName = (String) handler;</span><br><span class="line">			<span class="keyword">if</span> (getApplicationContext().isSingleton(handlerName)) &#123;</span><br><span class="line">				resolvedHandler = getApplicationContext().getBean(handlerName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Object mappedHandler = <span class="keyword">this</span>.handlerMap.get(urlPath);</span><br><span class="line">		<span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (mappedHandler != resolvedHandler) &#123;</span><br><span class="line">			<span class="comment">// 抛出异常，同一url 全路径完整匹配到多个Handler...</span></span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">						<span class="string">"Cannot map "</span> + getHandlerDescription(handler) + <span class="string">" to URL path ["</span> + urlPath +</span><br><span class="line">						<span class="string">"]: There is already "</span> + getHandlerDescription(mappedHandler) + <span class="string">" mapped."</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (urlPath.equals(<span class="string">"/"</span>)) &#123;</span><br><span class="line">			    <span class="comment">//设置rootHandler</span></span><br><span class="line">				setRootHandler(resolvedHandler);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (urlPath.equals(<span class="string">"/*"</span>)) &#123;</span><br><span class="line">			 <span class="comment">//设置defaultHandler</span></span><br><span class="line">				setDefaultHandler(resolvedHandler);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">			    <span class="comment">//添加url : handler 至 Map</span></span><br><span class="line">				<span class="keyword">this</span>.handlerMap.put(urlPath, resolvedHandler);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><br><br>AbstractUrlHandlerMapping定义了整体架构，子类只需要将Map初始化就可以了。<br>#### SimpleUrlHandlerMapping<br><font color="red">SimpleUrlHandlerMapping</font>通过重写<font color="red">initApplicationContext</font>方法来注册Handler，它的代码非常简单，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.springframework.web.servlet.handler.SimpleUrlHandlerMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleUrlHandlerMapping</span> <span class="keyword">extends</span> <span class="title">AbstractUrlHandlerMapping</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; urlMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//提供设置urlMap接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMappings</span><span class="params">(Properties mappings)</span> </span>&#123;</span><br><span class="line">        CollectionUtils.mergePropertiesIntoMap(mappings, <span class="keyword">this</span>.urlMap);</span><br><span class="line">    &#125;</span><br><span class="line">    	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initApplicationContext</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.initApplicationContext();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用registerHandlers</span></span><br><span class="line">        registerHandlers(<span class="keyword">this</span>.urlMap);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerHandlers</span><span class="params">(Map&lt;String, Object&gt; urlMap)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( !urlMap.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : urlMap.entrySet()) &#123;</span><br><span class="line">                String url = entry.getKey();</span><br><span class="line">                Object handler = entry.getValue();</span><br><span class="line">                <span class="comment">// url以"/"起始..</span></span><br><span class="line">                <span class="keyword">if</span> (!url.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">                    url = <span class="string">"/"</span> + url;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// trim</span></span><br><span class="line">                <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                    handler = ((String) handler).trim();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//调用父类方法registerHandler</span></span><br><span class="line">                registerHandler(url, handler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>#### AbstractDetectingUrlHandlerMapping<br><font color="red">AbstractDetectingUrlHandlerMapping</font>也是通过重写<font color="red">initApplicationContext</font>方法来注册Handler的，在方法中调用了detectHandlers，它的逻辑比较简单，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.springframework.web.servlet.handler.AbstractDetectingUrlHandlerMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDetectingUrlHandlerMapping</span> <span class="keyword">extends</span> <span class="title">AbstractUrlHandlerMapping</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//标识是否从SpringMVC及其父容器查找Handler</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> detectHandlersInAncestorContexts = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initApplicationContext</span><span class="params">()</span> <span class="keyword">throws</span> ApplicationContextException </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.initApplicationContext();</span><br><span class="line">		detectHandlers();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">detectHandlers</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">//detectHandlersInAncestorContexts为ture,从springMVC以及其祖先上下文寻找bean,否则仅从SpringMVC容器中寻找</span></span><br><span class="line">		String[] beanNames = (<span class="keyword">this</span>.detectHandlersInAncestorContexts ?</span><br><span class="line">				BeanFactoryUtils.beanNamesForTypeIncludingAncestors(getApplicationContext(), Object.class) :</span><br><span class="line">				getApplicationContext().getBeanNamesForType(Object.class));</span><br><span class="line"></span><br><span class="line">		<span class="comment">//对每个bean 如果能解析出url,就注册到父类的map中。</span></span><br><span class="line">		<span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">		    <span class="comment">//determineUrlsForHandler 模板方法，由子类实现。</span></span><br><span class="line">			String[] urls = determineUrlsForHandler(beanName);</span><br><span class="line">			<span class="keyword">if</span> (!ObjectUtils.isEmpty(urls)) &#123;</span><br><span class="line">				<span class="comment">//注册到父类Map中</span></span><br><span class="line">				registerHandler(urls, beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>AbstractDetectingUrlHandlerMapping有三个子类：<br>1. DefaultAnnotationHandlerMapping<br>2. BeanNameUrlHandlerMapping<br>3. AbstractControllerUrlHandlerMapping<br><br>DefaultAnnotationHandlerMapping<br><br>通过过判断类以及方法是否存在RequestMapping.class注解，来寻找urls：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAnnotationHandlerMapping</span> <span class="keyword">extends</span> <span class="title">AbstractDetectingUrlHandlerMapping</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> String[] determineUrlsForHandler(String beanName) &#123;</span><br><span class="line">    		ApplicationContext context = getApplicationContext();</span><br><span class="line">    		Class&lt;?&gt; handlerType = context.getType(beanName);</span><br><span class="line">    		 <span class="comment">//寻找 @RequestMapping bean...</span></span><br><span class="line">    		RequestMapping mapping = context.findAnnotationOnBean(beanName, RequestMapping.class);</span><br><span class="line">    		<span class="keyword">if</span> (mapping != <span class="keyword">null</span>) &#123;</span><br><span class="line">    			<span class="comment">//type即类级别的注解</span></span><br><span class="line">    			<span class="keyword">this</span>.cachedMappings.put(handlerType, mapping);</span><br><span class="line">    			Set&lt;String&gt; urls = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;();</span><br><span class="line">    			String[] typeLevelPatterns = mapping.value();</span><br><span class="line">    			<span class="keyword">if</span> (typeLevelPatterns.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    				<span class="comment">//方法级别的注解</span></span><br><span class="line">    				String[] methodLevelPatterns = determineUrlsForHandlerMethods(handlerType, <span class="keyword">true</span>);</span><br><span class="line">    				<span class="keyword">for</span> (String typeLevelPattern : typeLevelPatterns) &#123;</span><br><span class="line">    					<span class="keyword">if</span> (!typeLevelPattern.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">    						typeLevelPattern = <span class="string">"/"</span> + typeLevelPattern;</span><br><span class="line">    					&#125;</span><br><span class="line">    					<span class="comment">//存在为空的Method-Mapping</span></span><br><span class="line">    					<span class="keyword">boolean</span> hasEmptyMethodLevelMappings = <span class="keyword">false</span>;</span><br><span class="line">    					<span class="keyword">for</span> (String methodLevelPattern : methodLevelPatterns) &#123;</span><br><span class="line">    						<span class="keyword">if</span> (methodLevelPattern == <span class="keyword">null</span>) &#123;</span><br><span class="line">    							hasEmptyMethodLevelMappings = <span class="keyword">true</span>;</span><br><span class="line">    						&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    						    <span class="comment">//将 类级别url + 方法级别url 拼接</span></span><br><span class="line">                                String combinedPattern = getPathMatcher().combine(typeLevelPattern, methodLevelPattern);</span><br><span class="line">                                addUrlsForPath(urls, combinedPattern);</span><br><span class="line">                            &#125;</span><br><span class="line">    					&#125;</span><br><span class="line">    					</span><br><span class="line">    					<span class="comment">/**</span></span><br><span class="line"><span class="comment">    					 * 如果<span class="doctag">@RequestMapping</span>.value == null的 方法 或者 是Controller子类(controller接口定义如下：)</span></span><br><span class="line"><span class="comment">    					 public interface Controller &#123;</span></span><br><span class="line"><span class="comment">                          	ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception;</span></span><br><span class="line"><span class="comment">                          &#125;</span></span><br><span class="line"><span class="comment">                          </span></span><br><span class="line"><span class="comment">                         * 将 类级别url 添加urls中</span></span><br><span class="line"><span class="comment">    					 */</span></span><br><span class="line">    					<span class="keyword">if</span> (hasEmptyMethodLevelMappings || org.springframework.web.servlet.mvc.Controller.class.isAssignableFrom(handlerType)) &#123;</span><br><span class="line">    						addUrlsForPath(urls, typeLevelPattern);</span><br><span class="line">    					&#125;</span><br><span class="line">    				&#125;</span><br><span class="line">    				<span class="keyword">return</span> StringUtils.toStringArray(urls);</span><br><span class="line">    			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//直接寻找 @RequestMapping 方法</span></span><br><span class="line">                    <span class="keyword">return</span> determineUrlsForHandlerMethods(handlerType, <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">    			</span><br><span class="line">    		&#125;<span class="comment">//存在@Controller注解，但是Controller没有设置@RequestMapping</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (AnnotationUtils.findAnnotation(handlerType, Controller.class) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//直接寻找Controller内定义的方法</span></span><br><span class="line">                <span class="keyword">return</span> determineUrlsForHandlerMethods(handlerType, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">             &#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    <span class="keyword">protected</span> String[] determineUrlsForHandlerMethods(Class&lt;?&gt; handlerType, <span class="keyword">final</span> <span class="keyword">boolean</span> hasTypeLevelMapping) &#123;</span><br><span class="line">            <span class="comment">//获取自类的url结果，此处返回为空</span></span><br><span class="line">    		String[] subclassResult = determineUrlsForHandlerMethods(handlerType);</span><br><span class="line">    		<span class="keyword">if</span> (subclassResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">    			<span class="keyword">return</span> subclassResult;</span><br><span class="line">    		&#125;</span><br><span class="line">    </span><br><span class="line">    		<span class="keyword">final</span> Set&lt;String&gt; urls = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;();</span><br><span class="line">    		Set&lt;Class&lt;?&gt;&gt; handlerTypes = <span class="keyword">new</span> LinkedHashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">    		handlerTypes.add(handlerType);</span><br><span class="line">    		handlerTypes.addAll(Arrays.asList(handlerType.getInterfaces()));</span><br><span class="line">    		</span><br><span class="line">    		<span class="comment">//遍历类 +以及该类 所有的接口 中所有方法存在@RequestMapping的方法。</span></span><br><span class="line">    		<span class="keyword">for</span> (Class&lt;?&gt; currentHandlerType : handlerTypes) &#123;</span><br><span class="line">    			ReflectionUtils.doWithMethods(currentHandlerType, <span class="keyword">new</span> ReflectionUtils.MethodCallback() &#123;</span><br><span class="line">    				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWith</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    					RequestMapping mapping = AnnotationUtils.findAnnotation(method, RequestMapping.class);</span><br><span class="line">    					<span class="keyword">if</span> (mapping != <span class="keyword">null</span>) &#123;</span><br><span class="line">    						String[] mappedPatterns = mapping.value();</span><br><span class="line">    						<span class="keyword">if</span> (mappedPatterns.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    							<span class="keyword">for</span> (String mappedPattern : mappedPatterns) &#123;</span><br><span class="line">    								<span class="keyword">if</span> (!hasTypeLevelMapping &amp;&amp; !mappedPattern.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">    									mappedPattern = <span class="string">"/"</span> + mappedPattern;</span><br><span class="line">    								&#125;</span><br><span class="line">    								addUrlsForPath(urls, mappedPattern);</span><br><span class="line">    							&#125;</span><br><span class="line">    						&#125;</span><br><span class="line">    						<span class="keyword">else</span> <span class="keyword">if</span> (hasTypeLevelMapping) &#123;</span><br><span class="line">    							urls.add(<span class="keyword">null</span>);</span><br><span class="line">    						&#125;</span><br><span class="line">    					&#125;</span><br><span class="line">    				&#125;</span><br><span class="line">    			&#125;, ReflectionUtils.USER_DECLARED_METHODS);</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">return</span> StringUtils.toStringArray(urls);</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	</span><br><span class="line">    <span class="keyword">protected</span> String[] determineUrlsForHandlerMethods(Class&lt;?&gt; handlerType) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>BeanNameUrlHandlerMapping<br><br>BeanNameUrlHandlerMapping只有一个方法<font color="red">determineUrlsForHandler</font>，检查beanName和alias是不是以”/“开头，如果是就将其作为url。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanNameUrlHandlerMapping</span> <span class="keyword">extends</span> <span class="title">AbstractDetectingUrlHandlerMapping</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> String[] determineUrlsForHandler(String beanName) &#123;</span><br><span class="line">		List&lt;String&gt; urls = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		<span class="keyword">if</span> (beanName.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">			urls.add(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		String[] aliases = getApplicationContext().getAliases(beanName);</span><br><span class="line">		<span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">			<span class="keyword">if</span> (alias.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">				urls.add(alias);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> StringUtils.toStringArray(urls);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>AbstractControllerUrlHandlerMapping<br><br>是将实现了<font color="red">Controller接口</font>或者<font color="red">添加@Controller注解</font>的bean作为Handler，并且可以通过设置<font color="red">excludedPackages</font>和<font color="red">excludedClasses</font>派出不必要的packages和classes。<font color="red">determineUrlsForHandler</font>方法的作用是将符合条件的Handler找出来，而具体用什么Url则交给模板方法<font color="red">buildUrlsForHandler</font>由子类去实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.springframework.web.servlet.mvc.support.AbstractControllerUrlHandlerMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractControllerUrlHandlerMapping</span> <span class="keyword">extends</span> <span class="title">AbstractDetectingUrlHandlerMapping</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ControllerTypePredicate predicate = <span class="keyword">new</span> AnnotationControllerTypePredicate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; excludedPackages = Collections.singleton(<span class="string">"org.springframework.web.servlet.mvc"</span>);</span><br><span class="line">	<span class="keyword">private</span> Set&lt;Class&gt; excludedClasses = Collections.emptySet();</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] determineUrlsForHandler(String beanName) &#123;</span><br><span class="line">        Class beanClass = getApplicationContext().getType(beanName);</span><br><span class="line">        <span class="comment">//判断是否支持beanClass类型</span></span><br><span class="line">        <span class="keyword">if</span> (isEligibleForMapping(beanName, beanClass)) &#123;</span><br><span class="line">            <span class="comment">//模板方法，由子类实现</span></span><br><span class="line">            <span class="keyword">return</span> buildUrlsForHandler(beanName, beanClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isEligibleForMapping</span><span class="params">(String beanName, Class beanClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beanClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//排除classes</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.excludedClasses.contains(beanClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//排除package..</span></span><br><span class="line">        String beanClassName = beanClass.getName();</span><br><span class="line">        <span class="keyword">for</span> (String packageName : <span class="keyword">this</span>.excludedPackages) &#123;</span><br><span class="line">            <span class="keyword">if</span> (beanClassName.startsWith(packageName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断beanClass是否为Controller子类或者 存在@Controller注解</span></span><br><span class="line">        <span class="keyword">return</span> isControllerType(beanClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>它有两个子类：<font color="red">ControllerBeanNameHandlerMapping和ControllerClassNameHandlerMapping</font>

<ol>
<li><font color="red">ControllerBeanNameHandlerMapping</font>: 将beanName和alias 当成url;</li>
<li><font color="red">ControllerClassNameHandlerMapping</font>: 将ClassName当成url;<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerClassNameHandlerMapping</span> <span class="keyword">extends</span> <span class="title">AbstractControllerUrlHandlerMapping</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果beanclass以"Controller" 则剔除此部分.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONTROLLER_SUFFIX = <span class="string">"Controller"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> caseSensitive = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> String pathPrefix;</span><br><span class="line">    <span class="keyword">private</span> String basePackage;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> StringBuilder <span class="title">buildPathPrefix</span><span class="params">(Class beanClass)</span> </span>&#123;</span><br><span class="line">        StringBuilder pathMapping = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.pathPrefix != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pathMapping.append(<span class="keyword">this</span>.pathPrefix);</span><br><span class="line">            pathMapping.append(<span class="string">"/"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             pathMapping.append(<span class="string">"/"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//如果配置了basepackage,则subPackage转换为path...</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.basePackage != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String packageName = ClassUtils.getPackageName(beanClass);</span><br><span class="line">            <span class="keyword">if</span> (packageName.startsWith(<span class="keyword">this</span>.basePackage)) &#123;</span><br><span class="line">                String subPackage = packageName.substring(<span class="keyword">this</span>.basePackage.length()).replace(<span class="string">'.'</span>, <span class="string">'/'</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//判断是否大小写敏感</span></span><br><span class="line">                pathMapping.append(<span class="keyword">this</span>.caseSensitive ? subPackage : subPackage.toLowerCase());</span><br><span class="line">                pathMapping.append(<span class="string">"/"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pathMapping;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2017/04/30/springmvc组件之HandlerMapping/" data-id="cjyms8jwt0015dwudh087de54" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Mybatis（插件）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2017/04/01/Mybatis（插件）/" class="article-date">
  <time datetime="2017-04-01T12:26:15.000Z" itemprop="datePublished">2017-04-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2017/04/01/Mybatis（插件）/">Mybatis（插件）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>先从一个简单的例子入手：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123;<span class="meta">@Signature</span>(type = StatementHandler.class, method = <span class="string">"prepare"</span>, args = &#123;Connection.class&#125;)&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> limit;</span><br><span class="line">    <span class="keyword">private</span> String dbType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LMT_TABLE_NAME = <span class="string">"MY_TABLE"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    	StatementHandler stmtHandler = (StatementHandler) invocation.getTarget();</span><br><span class="line">        MetaObject metaStmtHandler = SystemMetaObject.forObject(stmtHandler);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要实现Interceptor：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span></span>&#123;</span><br><span class="line">	<span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">    <span class="function">Object <span class="title">plugin</span><span class="params">(Object target)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>intercept方法：覆盖所拦截对象原有方法，其中参数Invocation对象，通过它可以反射调度原来对象的方法。</p>
<p>plugin方法：target是被拦截对象，它的作用是给被拦截对象生成一个代理对象，并返回。</p>
<p>setProperties方法：允许在plugin元素中配置所需参数，方法在插件初始化的时候就被调用了一次，然后把插件对象存入到配置中，以便后面取出。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2017/04/01/Mybatis（插件）/" data-id="cjyms8jrw000adwudhw1kz13m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-InnoDB可重复读" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2016/09/05/InnoDB可重复读/" class="article-date">
  <time datetime="2016-09-05T14:48:33.000Z" itemprop="datePublished">2016-09-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2016/09/05/InnoDB可重复读/">InnoDB可重复读</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在RC(Read Committed)和RR(Repeatable Read)两种事务隔离级别下，InnoDB存在两种数据读取方式：</p>
<h3 id="快照读（Snapshot-Read）"><a href="#快照读（Snapshot-Read）" class="headerlink" title="快照读（Snapshot Read）"></a>快照读（Snapshot Read）</h3><p>快照读读取的都是快照数据，快照怎么来，在InnoDB引擎下是基于undo log，那么undo log又是什么？举个例子：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--表结构</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`innodb_test`</span>(</span><br><span class="line">	<span class="string">`id`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="string">`name`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="string">`id`</span>),</span><br><span class="line">    <span class="keyword">INDEX</span> <span class="string">`idx_age`</span>(<span class="string">`age`</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--初始数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`innodb_test`</span>(<span class="string">`id`</span>, <span class="string">`name`</span>, <span class="string">`age`</span>)<span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">'凋残'</span>, <span class="number">100</span>),(<span class="number">2</span>, <span class="string">'庄周'</span>, <span class="number">120</span>),(<span class="number">3</span>, <span class="string">'项羽'</span>, <span class="number">130</span>);</span><br></pre></td></tr></table></figure></p>
<ol>
<li>id=1的初始数据行</li>
</ol>
<table>
<thead>
<tr>
<th>回滚指针</th>
<th>事务ID</th>
<th>id</th>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr>
<td>无</td>
<td>无</td>
<td>1</td>
<td>凋残</td>
<td>100</td>
</tr>
</tbody>
</table>
<ol start="2">
<li>事务A执行如下语句<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> innodb_test <span class="keyword">SET</span> <span class="keyword">name</span> = <span class="string">'嬴政'</span>，age = <span class="number">90</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>此时innodb会做如下操作：</p>
<pre><code>1. 把该行修改前的值Copy到undo log(Copy on write)；
2. 修改当前行的值，填写事务编号，使回滚指针指向undo log中的修改前的行。
</code></pre><p><img src="/lfhboke.github.io/css/images/repeatread.PNG" alt="repeatread"></p>
<ol start="2">
<li>事务B执行如下语句<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> innodb_test <span class="keyword">SET</span> <span class="keyword">name</span>=<span class="string">'甄姬'</span>, age=<span class="number">91</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>此时undo log中有2条记录，它们通过回滚指针相连。<br><img src="/lfhboke.github.io/css/images/repeatread2.PNG" alt="repeatread2"><br>undo log的存在解决了两个问题，一是数据回滚，二是实现了MVCC，快照读取的就是undo log中的数据，所以这种读取是不需要加锁的，避免了读写冲突。常见的快照读语句就是最常见的SELECT，比如<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> innodb_test <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>快照读在RC和RR隔离级别下的表现却是不一样的，为了方便说明，现在将数据还原到初始数据，然后按照下表的顺序操作。</p>
<table>
<thead>
<tr>
<th>#</th>
<th>事务1</th>
<th>事务2</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>begin;</td>
<td>begin;</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>SELECT * FROM innodb_test WHERE id=1;//输出1-凋残-100</td>
</tr>
<tr>
<td>3</td>
<td>UPDATE innodb_test SET name=’嬴政’, age=90 WHERE id=1;</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>commit;</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>SELECT * FROM innodb_test WHERE id=1;//输出？？？</td>
</tr>
</tbody>
</table>
<p>. RC</p>
<p>输出的最新提交的结果（1-嬴政-90），RC级别的快照读遵循以下规则：</p>
<p>. 优先读取当前事务修改的数据，自己修改的，当然可以读到；</p>
<p>. 其次读取最新已提交数据。</p>
<p>会出现前后读取结果不一样的情况，但读取的是最新数据。</p>
<p>. RR</p>
<p>输出结果和第一次查询是一样的（1-凋残-100），RR级别的快照读遵循以下规则：</p>
<p>. 优先读取当前事务修改的数据，和RC一样；</p>
<p>. 其次读取小于当前事务id的最新一条已提交数据，此时数据版本已经确定了，后面的快照读取始终读取这个版本。</p>
<p>通过这样的机制，保证了快照读的可重复读，但读取到的数据很可能已经过期了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2016/09/05/InnoDB可重复读/" data-id="cjyms8jr00003dwud9tscfv0z" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-BlockQueue线程容器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2016/09/05/BlockQueue线程容器/" class="article-date">
  <time datetime="2016-09-05T13:25:57.000Z" itemprop="datePublished">2016-09-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2016/09/05/BlockQueue线程容器/">BlockQueue线程容器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>blockQueue作为线程容器、阻塞队列，多用于生产者、消费者的关系模式中，保障并发编程线程同步，线程池中被用于当作存储任务的队列，还可以保证线程执行的有序性。</p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="生产"><a href="#生产" class="headerlink" title="生产"></a>生产</h4><ol>
<li>add(obj)：往队列里面增加一个对象，如果队列没有空间抛出异常，反之返回true。</li>
<li>offer(obj)：往队列增加一个对象，返回true/false</li>
<li>put(obj)：往队列增加一个对象，如果没有空间，则会阻塞该线程，直到有空间。<h4 id="消费"><a href="#消费" class="headerlink" title="消费"></a>消费</h4></li>
<li>poll(time)：取出排在首位的对象，如果在一定时间内没有返回，则会返回null</li>
<li>take()：取出排在首位的对象，如果队列中没有数据，则会阻塞该线程直到有数据。<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4></li>
<li>contains(obj)：查询是否存在某个元素，返回true/false。</li>
<li>peek()：返回队列头部的元素，无则返回null。<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3></li>
<li>容量有限，可以限定队列的长度，如果没有主动显式队列长度的情况下，默认长度为Integer.MAX_VALUE</li>
<li>内存一致性，遵循happened-before原则，即写操作总是先于后面的读操作。</li>
<li>因为其继承Collection接口，所以可以使用集合的接口，但某些接口并不保证立即执行，因为其内部维护着内部锁（ReentrantLock），所以只有在获取锁的情况下才会执行对应的代码，以remove()源码为例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(o == <span class="keyword">null</span>) </span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="keyword">final</span> <span class="keyword">int</span> putIndex = <span class="keyword">this</span>.putIndex;</span><br><span class="line">            <span class="keyword">int</span> i = takeIndex;</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">            	<span class="keyword">if</span>(o.equals(items[i])) &#123;</span><br><span class="line">                	removeAt(i);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(++i == items.length&#123;</span><br><span class="line">                	i = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">while</span>(i ! = putIndex );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    	lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>每次操作都会去获取锁，如果锁被其他操作暂用，没有获取到锁，则只能去排队，所以上面代码并不会立即执行。</p>
<h3 id="常用分类"><a href="#常用分类" class="headerlink" title="常用分类"></a>常用分类</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>创建队列时，可以添加fair参数，用于声明内部锁是否是公平锁，公平锁用于决定队列里面的任务是否会按照顺序执行。</p>
<h5 id="公平锁："><a href="#公平锁：" class="headerlink" title="公平锁："></a>公平锁：</h5><p>显式声明为公平锁的任务执行完全按照队列的顺序执行，新的任务进来会存放在队尾。</p>
<h5 id="非公平锁："><a href="#非公平锁：" class="headerlink" title="非公平锁："></a>非公平锁：</h5><p>队列里面的任务可以按照顺序执行，但是新的任务可能会与队列争抢CPU资源，不保证队列外的顺序。</p>
<ol>
<li>ArrayBlockingQueue，创建固定大小的队列，内部维护一个数组，遵循FIFO原则</li>
<li>LinkedBlockingQueue，可以自定义队列长度，无指定的情况下默认为Integer.MAX_VALUE，内部维护着一个链表，遵循着FIFO原则</li>
<li>PriorityBlockingQueue，类似ArrayBlockingQueue，内部维护一个数组，但并不按照FIFO原则，其内部有个compare属性决定队列任务的执行顺序。</li>
<li>SynchronousQueue，特殊的队列，内部无存储空间维护队列，只有当生产者和消费者同时存在时，才会执行，类似于管道。<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4></li>
<li>生产者与消费者案例，一个生产者与多个消费者。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockQueueDemo</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 生产者</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Productor</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    	<span class="keyword">private</span> BlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> LinkedBlockingDeque();</span><br><span class="line">        Productor(BlockingQueue blockingQueue) &#123;</span><br><span class="line">        	<span class="keyword">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            	<span class="keyword">try</span>&#123;</span><br><span class="line">                	Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                    blockingQueue.put(i);</span><br><span class="line">                    blockingQueue.put(i);</span><br><span class="line">                    System.out.println(<span class="string">"生产者产生了产品"</span> + i);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">                	e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> BlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> LinkedBlockingDeque();</span><br><span class="line"></span><br><span class="line">        Consumer(BlockingQueue blockingQueue)&#123;</span><br><span class="line">            <span class="keyword">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String name = Thread.currentThread().getName();</span><br><span class="line">                    Integer queueData = blockingQueue.take();</span><br><span class="line">                    System.out.println(<span class="string">"消费者"</span>+name+<span class="string">"消费了产品"</span>+queueData);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一个生产者对应多个消费者，采用BlockQueue作为缓冲区</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> LinkedBlockingDeque();</span><br><span class="line">        Productor productor = <span class="keyword">new</span> Productor(blockingQueue);</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(blockingQueue);</span><br><span class="line">        Consumer consumer2 = <span class="keyword">new</span> Consumer(blockingQueue);</span><br><span class="line">        <span class="keyword">new</span> Thread(productor).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(consumer).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(consumer2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">执行结果：</span><br><span class="line">消费者Thread-<span class="number">2</span>消费了产品<span class="number">21</span></span><br><span class="line">生产者产品了产品<span class="number">22</span></span><br><span class="line">消费者Thread-<span class="number">1</span>消费了产品<span class="number">22</span></span><br><span class="line">生产者产品了产品<span class="number">23</span></span><br><span class="line">消费者Thread-<span class="number">2</span>消费了产品<span class="number">23</span></span><br><span class="line">生产者产品了产品<span class="number">24</span></span><br><span class="line">消费者Thread-<span class="number">1</span>消费了产品<span class="number">24</span></span><br><span class="line">生产者产品了产品<span class="number">25</span></span><br><span class="line">消费者Thread-<span class="number">2</span>消费了产品<span class="number">25</span></span><br><span class="line">生产者产品了产品<span class="number">26</span></span><br><span class="line">消费者Thread-<span class="number">1</span>消费了产品<span class="number">26</span></span><br><span class="line">生产者产品了产品<span class="number">27</span></span><br><span class="line">消费者Thread-<span class="number">2</span>消费了产品<span class="number">27</span></span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2016/09/05/BlockQueue线程容器/" data-id="cjyms8jqn0001dwud17z5lr9p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-深入理解ReentrantLock" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2016/09/04/深入理解ReentrantLock/" class="article-date">
  <time datetime="2016-09-04T12:52:59.000Z" itemprop="datePublished">2016-09-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2016/09/04/深入理解ReentrantLock/">深入理解ReentrantLock</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Java中通常实现锁有两种方式，一种是synchronized关键字，另一种是Lock。二者其实并没有什么必然联系，但是各有各的特点，在使用中可以进行取舍的使用。</p>
<h4 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h4><p>首先最大的不同：synchronized是基于JVM层面实现的，而Lock是基于JDK层面实现的。</p>
<h4 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h4><p>对于使用者的直观体验上Lock是比较复杂的，需要lock和realse，如果忘记释放锁就会产生死锁的问题，所以，通常需要在finally中进行锁的释放。但是synchronized的使用十分简单，只需要对自己的方法或者关注的同步对象或类使用synchronized关键字即可。但是对于锁的力度控制比较粗，同时对于实现一些锁的状态的转移比较困难。</p>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><table>
<thead>
<tr>
<th>tips</th>
<th>synchronized</th>
<th>Lock   </th>
</tr>
</thead>
<tbody>
<tr>
<td>锁获取超时</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>获取锁响应中断</td>
<td>不支持</td>
<td>支持</td>
</tr>
</tbody>
</table>
<h4 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h4><p>在JDK5之后synchronized引入了偏向锁，轻量级锁和重量级锁，从而大大的提高了synchronized的性能，同时对于synchronized的优化也在继续进行。</p>
<p>Lock的实现主要有ReentrantLock、ReadLock和WriteLock，后两者接触不多，所以简单分析一下ReentrantLock的实现和运行机制。</p>
<p>ReentrantLock实现Lock接口，在ReentrantLock中引用了AbstractQueuedSynchronizer的子类，所有的同步操作都是依靠AbstractQueuedSynchronizer（队列同步器）实现。<br><img src="/lfhboke.github.io/css/images/lockuml.PNG" alt="lockuml"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7373984872572414699L</span>;</span><br><span class="line">    <span class="comment">/** Synchronizer providing all implementation mechanics */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Base of synchronization control for this lock. Subclassed</span></span><br><span class="line"><span class="comment">     * into fair and nonfair versions below. Uses AQS state to</span></span><br><span class="line"><span class="comment">     * represent the number of holds on the lock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5179523762034025860L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Performs &#123;<span class="doctag">@link</span> Lock#lock&#125;. The main reason for subclassing</span></span><br><span class="line"><span class="comment">         * is to allow fast path for nonfair version.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Performs non-fair tryLock.  tryAcquire is</span></span><br><span class="line"><span class="comment">         * implemented in subclasses, but both need nonfair</span></span><br><span class="line"><span class="comment">         * try for trylock method.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                free = <span class="keyword">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// While we must in general read state before owner,</span></span><br><span class="line">            <span class="comment">// we don't need to do so to check if current thread is owner</span></span><br><span class="line">            <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Methods relayed from outer class</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> Thread <span class="title">getOwner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">0</span> ? <span class="keyword">null</span> : getExclusiveOwnerThread();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> isHeldExclusively() ? getState() : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Reconstitutes this lock instance from a stream.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> s the stream</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">            s.defaultReadObject();</span><br><span class="line">            setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的代码可以看出来首先ReentrantLock是可序列化的，其次是ReentrantLock里有一个对AbstractQueuedSynchronizer的引用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment">     * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment">     * given fairness policy.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面代码可以看出，ReentrantLock支持两种两种锁模式，公平锁和非公平锁。默认的实现是非公平的。公平和非公平锁的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sync object for non-fair locks</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">         * acquire on failure.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sync object for fair locks</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="comment">         * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>AbstractQueuedSynchronizer是一个抽象类，所以在使用这个同步器的时候，需要通过自己实现预期的逻辑，Sync、FairSync和NonfairSync都是ReentrantLock为了实现自己的需求而实现的内部类。</p>
<p>在ReentrantLock<br>调用lock()的时候，调用的是下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires the lock.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Acquires the lock if it is not held by another thread and returns</span></span><br><span class="line"><span class="comment">     * immediately, setting the lock hold count to one.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If the current thread already holds the lock then the hold</span></span><br><span class="line"><span class="comment">     * count is incremented by one and the method returns immediately.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If the lock is held by another thread then the</span></span><br><span class="line"><span class="comment">     * current thread becomes disabled for thread scheduling</span></span><br><span class="line"><span class="comment">     * purposes and lies dormant until the lock has been acquired,</span></span><br><span class="line"><span class="comment">     * at which time the lock hold count is set to one.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>sync的实现是NonfairSync，所以调用的是NonfairSync的lock方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sync object for non-fair locks</span></span><br><span class="line"><span class="comment">     * tips：调用Lock的时候，尝试获取锁，这里采用的CAS去尝试获取锁，如果获取锁成功</span></span><br><span class="line"><span class="comment">     *       那么，当前线程获取到锁，如果失败，调用acquire处理。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">         * acquire on failure.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来看看compareAndSetState方法是怎么进行锁的获取操作的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically sets synchronization state to the given updated</span></span><br><span class="line"><span class="comment">     * value if the current state value equals the expected value.</span></span><br><span class="line"><span class="comment">     * This operation has memory semantics of a &lt;tt&gt;volatile&lt;/tt&gt; read</span></span><br><span class="line"><span class="comment">     * and write.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if successful. False return indicates that the actual</span></span><br><span class="line"><span class="comment">     *         value was not equal to the expected value.</span></span><br><span class="line"><span class="comment">     *         </span></span><br><span class="line"><span class="comment">     * tips： 1.compareAndSetState的实现主要是通过Unsafe类实现的。</span></span><br><span class="line"><span class="comment">     *       2.之所以命名为Unsafe，是因为这个类对于JVM来说是不安全的，我们平时也是使用不了这个类的。</span></span><br><span class="line"><span class="comment">     *       3.Unsafe类内封装了一些可以直接操作指定内存位置的接口，是不是感觉和C有点像了？</span></span><br><span class="line"><span class="comment">     *       4.Unsafe类封装了CAS操作，来达到乐观的锁的争抢的效果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>主要的说明都在方法的注释中，接下来简单的看一下compareAndSwaplant的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically update Java variable to &lt;tt&gt;x&lt;/tt&gt; if it is currently</span></span><br><span class="line"><span class="comment">     * holding &lt;tt&gt;expected&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if successful</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> expected,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>一个native方法，以CAS的方式将制定字段设置未指定的值。下面看看操作的stateOffset：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> stateOffset;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> headOffset;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> tailOffset;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> waitStatusOffset;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//这个方法很有意思，主要的意思是获取AbstractQueuedSynchronizer的state成员的偏移量</span></span><br><span class="line">           <span class="comment">//通过这个偏移量来更新state成员，另外state是volatile的来保证可见性。</span></span><br><span class="line">           stateOffset = unsafe.objectFieldOffset</span><br><span class="line">               (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">"state"</span>));</span><br><span class="line">           headOffset = unsafe.objectFieldOffset</span><br><span class="line">               (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">"head"</span>));</span><br><span class="line">           tailOffset = unsafe.objectFieldOffset</span><br><span class="line">               (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">"tail"</span>));</span><br><span class="line">           waitStatusOffset = unsafe.objectFieldOffset</span><br><span class="line">               (Node.class.getDeclaredField(<span class="string">"waitStatus"</span>));</span><br><span class="line">           nextOffset = unsafe.objectFieldOffset</span><br><span class="line">               (Node.class.getDeclaredField(<span class="string">"next"</span>));</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>对于竞争成功的线程会调用setExclusiveOwnerThread方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The current owner of exclusive mode synchronization.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the thread that currently owns exclusive access. A</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;null&lt;/tt&gt; argument indicates that no thread owns access.</span></span><br><span class="line"><span class="comment">     * This method does not otherwise impose any synchronization or</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;volatile&lt;/tt&gt; field accesses.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setExclusiveOwnerThread</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        exclusiveOwnerThread = t;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个实现是比较简单的，只是获取当前线程的引用，令AbstractOwnableSynchronizer中的exclusiveOwnerThread引用到当前线程。竞争失败的线程，会调用acquire方法，这个方法也是ReentrantLock设计的精华之处：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in exclusive mode, ignoring interrupts.  Implemented</span></span><br><span class="line"><span class="comment">     * by invoking at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;,</span></span><br><span class="line"><span class="comment">     * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment">     * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #tryAcquire&#125; until success.  This method can be used</span></span><br><span class="line"><span class="comment">     * to implement method &#123;<span class="doctag">@link</span> Lock#lock&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment">     *        can represent anything you like.</span></span><br><span class="line"><span class="comment">     * tips:此处主要是处理没有获取到锁的线程</span></span><br><span class="line"><span class="comment">     *   tryAcquire：重新进行一次锁获取和进行锁重入的处理。</span></span><br><span class="line"><span class="comment">     *      addWaiter：将线程添加到等待队列中。</span></span><br><span class="line"><span class="comment">     *   acquireQueued：自旋获取锁。      </span></span><br><span class="line"><span class="comment">     *      selfInterrupt：中断线程。</span></span><br><span class="line"><span class="comment">     *      三个条件的关系为and,如果 acquireQueued返回true，那么线程被中断selfInterrupt会中断线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>AbstractQueuedSynchronizer为抽象方法，调用tryAcquire时，调用的为NonfairSync的tryAcquire。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Performs non-fair tryLock.  tryAcquire is</span></span><br><span class="line"><span class="comment">        * implemented in subclasses, but both need nonfair</span></span><br><span class="line"><span class="comment">        * try for trylock method.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">           <span class="keyword">int</span> c = getState();</span><br><span class="line">           <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                   setExclusiveOwnerThread(current);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">               <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">               <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">               setState(nextc);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>nonfairTryAcquire方法主要是做冲入锁的实现，synchronized本身支持锁的重入，而ReetrantLock则是通过此处实现。在锁状态为0时，重新尝试获取锁。如果已经被占用，那么做一次是否当前线程为占用锁的线程的判断，如果是一样的那么进行计数，当然在锁的release过程中会进行递减，保证锁的正常释放。<br>如果没有重新获取到锁或者锁的占用线程和当前线程是一个线程，方法返回false。那么把线程添加到等待队列中，调用addWaiter：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates and enqueues node for current thread and given mode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the new node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> node's predecessor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里主要是用当前线程构建一个Node的等待队列双向链表，这里addWaiter中和enq的部分逻辑是重复的，个人感觉可能是如果能一次成功就避免了enq中的死循环。因为tail节点是volatile的同时node也是不会发生竞争的，所以node.prev=pred；是安全的。但是tail的next是不断竞争的，所以利用compareAndSetTail保证操作的串行化。</p>
<p>接下来调用acquireQueued方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in exclusive uninterruptible mode for thread already in</span></span><br><span class="line"><span class="comment">     * queue. Used by condition wait methods as well as acquire.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted while waiting</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>此处是做Node节点线程的自旋过程，自旋过程，自旋过程主要检查当前节点是不是head节点的next节点，如果是，则尝试获取锁，如果获取成功，那么释放当前节点，同时返回。至此一个非公平锁的锁获取过程结束。</p>
<p>如果这里一直不断的循环检查，其实是很耗费性能的。所以提供了shouldParkAfterFailedAcquire和parkAndCheckInterrupt，这两个方法就实现了线程的等待从而避免无限的轮询：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Checks and updates status for a node that failed to acquire.</span></span><br><span class="line"><span class="comment">     * Returns true if thread should block. This is the main signal</span></span><br><span class="line"><span class="comment">     * control in all acquire loops.  Requires that pred == node.prev</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pred node's predecessor holding status</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if thread should block</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">             * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">             * indicate retry.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">             * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">             * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>首先，检查一个当前Node的前置节点pred是否是SIGNAL，如果是SIGNAL，那么证明前置Node的线程已经Park了，如果waitStatus&gt;0，那么设置waitStatus为SIGNAL，因为调用shouldParkAfterFailedAcquire的方法为死循环调用，所以终将返回true。接下来看parkAndCheckInterrupt方法，当shouldParkAfterFailedAcquire返回True的时候执行parkAndCheckInterrupt方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>此方法比较简单，其实就是使当前的线程park，即暂停了线程的轮询。当Unlock时会做后续节点的Unpark唤醒线程继续争抢锁。<br>接下来看一下锁的释放过程，锁释放主要是通过unlock方法实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Attempts to release this lock.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;If the current thread is the holder of this lock then the hold</span></span><br><span class="line"><span class="comment">    * count is decremented.  If the hold count is now zero then the lock</span></span><br><span class="line"><span class="comment">    * is released.  If the current thread is not the holder of this</span></span><br><span class="line"><span class="comment">    * lock then &#123;<span class="doctag">@link</span> IllegalMonitorStateException&#125; is thrown.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalMonitorStateException if the current thread does not</span></span><br><span class="line"><span class="comment">    *         hold this lock</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       sync.release(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>主要是调用AbstractQueuedSynchronizer同步器的release方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Releases in exclusive mode.  Implemented by unblocking one or</span></span><br><span class="line"><span class="comment">     * more threads if &#123;<span class="doctag">@link</span> #tryRelease&#125; returns true.</span></span><br><span class="line"><span class="comment">     * This method can be used to implement method &#123;<span class="doctag">@link</span> Lock#unlock&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryRelease&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment">     *        can represent anything you like.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryRelease&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>tryRelease方法为ReentrantLock中的Sync的tryRelease方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                free = <span class="keyword">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<font color="red">ReentrantLock的非公平锁：现有线程与同步队列首部线程争抢锁</font>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2016/09/04/深入理解ReentrantLock/" data-id="cjyms8jwf0014dwudumnsizvo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JVM调优之JVM参数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2016/07/14/JVM调优之JVM参数/" class="article-date">
  <time datetime="2016-07-14T12:28:33.000Z" itemprop="datePublished">2016-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2016/07/14/JVM调优之JVM参数/">JVM调优之JVM参数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>-Xmx 512m：设置JVM最大堆内存为512M。</p>
<p>-Xms 512m：设置JVM初始堆内存为512M。</p>
<p>-Xss 128k：设置每个线程的栈大小。</p>
<p>-Xmn 512m：设置新生代大小为512M。</p>
<p>-XX:NewSize=512m：设置新生代初始值为512M。</p>
<p>-XX:MaxNewSize=1024m：设置新生代最大值为1024M。</p>
<p>-XX:PermSize=256m：设置永久代初始值为256M。</p>
<p>-XX:MaxPermSize=256m：设置永久代最大值为256M。</p>
<p>-XX:NewRatio=4：设置新生代（包括2个Eden和2个Survivor区）与老年代的比值。表示新生代比老年代为1：4.</p>
<p>-XX:SurvivorRatio=4:设置新生代中Eden区和Suvivor区的比值。表示2个Survivor区（JVM堆内存新生代中默认有2个大小相等的Suvivor区）与1个Eden区的比值为2：4。</p>
<p>-XX:MaxTenuringThreshold=7：表示一个对象如果在Suvivor区移动了7次还没有被垃圾回收就进入老年代。如果设置为0的话，则新生代不经过Survivor区直接进入老年代。</p>
<font color="red">-Xmn，-XX:NewSize/-XX:MaxNewSize,-XX:NewRatio3组参数都可以影响新生代，优先级如下</font>：<br><br><font color="red">高优先级:-XX:NewSize/-XX:MaxNewSize</font>

<font color="red">中优先级：-Xmn（默认等于-Xmn=-XX:NewSize=-XX:MaxNewSize=?）</font>

<font color="red">低优先级：-XX:NewRatio</font>

<h3 id="垃圾回收器选择"><a href="#垃圾回收器选择" class="headerlink" title="垃圾回收器选择"></a>垃圾回收器选择</h3><p>JVM给出了3种选择：串行收集器、并行收集器、并发收集器。串行收集器只适用于小数据量的情况，所以生产环境的选择主要是并行收集器和并发收集器。</p>
<p>-XX:+UseSerialGC：设置为串行收集器。</p>
<p>-XX:+UseParallelGC：设置并行收集器。此配置仅对新生代有效。即新生代使用并行收集，而老年代仍使用串行收集。</p>
<p>-XX:ParallelGCThreads=20：配置并行收集器的线程数，即：同时有多少个线程一起进行垃圾回收。建议配置与CPU数目相等。</p>
<p>-XX:+UseParallelOldGC：配置老年代垃圾收集方式为并行收集。</p>
<p>-XX:MaxGCPauseMillis=100：设置每次新生代垃圾回收的最长时间（单位毫秒）。如果无法满足此时间，JVM自动调整新生代大小，以满足此时间。</p>
<p>-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动调整新生代Eden区大小和Survivor区大小的比例，以达成目标系统规定的最低响应时间或者收集频率等指标。此参数建议在使用并行收集器时，一直打开。</p>
<p>-XX:+UseConcMarkSweepGC：即CMS收集，设置老年代为并发收集。CMS主要适合场景是对响应时间的重要性需求大于对吞吐量的需求，能够承受垃圾回收线程和应用线程共享CPU资源，并且应用中存在比较多的长生命周期的对象。CMS收集的目标是尽量减少应用的暂停时间，减少Full GC发生的机率，利用和应用程序并发的垃圾回收线程来标记清除老年代内存。</p>
<p>-XX:+UseParNewGC：设置新生代并发收集。可与CMS收集同时使用。</p>
<p>-XX:CMSFullGCsBeforeCompaction=0：由于并发收集器不对内存空间进行压缩和整理，所以运行一段时间并行收集以后会产生内存碎片，内存使用效率降低。此参数设置运行0次FullGC后对内存空间进行压缩和整理，即每次FullGC后立刻开始压缩和整理内存。</p>
<p>-XX:+UseCMSCompactAtFullCollection：打开内存空间的压缩和整理，在FullGC后执行。可能会影响性能，但可以消除内存碎片。</p>
<p>-XX:+CMSIncrementalMode：设置为增量收集模式。</p>
<p>-XX:CMSInitiatingOccupancyFraction=70：表示老年代内存使用到70%时开始执行CMS收集，以确保老年代有足够的空间接纳来自新生代的对象，避免FullGC的发生。</p>
<p>-XX:+ScavengeBeforeFullGC：新生代GC优于FullGC执行</p>
<p>-XX:-DisableExplicitGC：不响应System.gc()代码。</p>
<p>-XX:+UseThreadPriorities：启用本地线程优先级API。即使java.lang.Thread.setPriority()生效，不启用则无效。</p>
<p>-XX:+SoftRefLRUPolicyMSPerMB=0：软引用对象在最后一次被访问后能存活0毫秒。</p>
<p>-XX:TargetSurvivorRatio=90：允许90%的Survivor区被占用。提高对于Survivor区使用率。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2016/07/14/JVM调优之JVM参数/" data-id="cjyms8jqu0002dwudv163ial3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java线程池解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2016/06/03/java线程池解析/" class="article-date">
  <time datetime="2016-06-03T13:29:36.000Z" itemprop="datePublished">2016-06-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2016/06/03/java线程池解析/">java线程池解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>以源码入手：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//threadFactory用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字</span></span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>解释一下参数的含义：</p>
<ol>
<li>corePoolSize 线程池基本大小，核心线程池大小，活动线程小于corePoolSize则直接创建，大于等于则先加到workQueue，队列满了才创建新的线程。当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务等到需要执行的任务数大于线程池基本大小时不再创建。如果调用了线程池的prestartAllCoreThreads()方法，线程会提前创建并启动所有基本线程。</li>
<li>maximumPoolSize 最大线程数，超过就reject：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。</li>
<li>keepAliveTime 线程池工作线程空闲后，保持存活的时间。所以，如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。</li>
<li>unit 线程活动保持时间的单位：可选的单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、微妙（MICROSECONDS）和纳秒（NANOSECONDS）</li>
<li>workQueue 工作队列，线程池中的工作线程都是从这个工作队列源源不断的获取任务进行执行。<br>另外加俩个参数：</li>
<li>threadFactory 产生线程的工厂实例。</li>
<li>handler 线程饱和后的处理策略。<h3 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h3>线程池超过最大线程之后，对于新的线程采取的操作：<font color="red">AbortPolicy</font>

</li>
</ol>
<p>为Java线程池默认的阻塞策略，不执行此任务，而且直接抛出一个运行时异常，切记ThreadPoolExecutor.execute需要try catch，否则程序会直接退出。</p>
<font color="red">DiscardPolicy</font>

<p>直接抛弃，任务不执行，空方法</p>
<font color="red">DiscardOldestPolicy</font>

<p>从队列里面抛弃head的一个任务，并再次execute此task</p>
<font color="red">CallerRunsPolicy</font>

<p>在调用execute的线程里面执行此command，会阻塞入口(用于自定义拒绝策略)。<font color="red">实现RejectedExecutionHandler，并自己定义策略模式</font>。</p>
<h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><ol>
<li>如果当前运行线程少于corePoolSize，则创建新线程来执行任务。</li>
<li>如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。</li>
<li>如果无法将任务加入BlockingQueue，则在非corePool中创建新的线程来处理任务。</li>
<li>如果创建新线程使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3>首先看看execute的源码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(command == <span class="keyword">null</span>) &#123;</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> NullPointException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">//工作线程数小于核心线程数</span></span><br><span class="line">    <span class="keyword">if</span>(workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">    	<span class="comment">//直接启动新线程，true表示会再次检查workerCount是否小于corePoolSize</span></span><br><span class="line">        <span class="keyword">if</span>(addWorker(command, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        	<span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果工作线程数大于等于核心线程数，线程的状态未Running并且队列notfull</span></span><br><span class="line">    <span class="keyword">if</span>(isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">    	<span class="comment">//再次检查线程的运行状态，如果不是Running直接从队列中移除</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span>(!isRunning(recheck) &amp;&amp; remove(command)) &#123;</span><br><span class="line">        	<span class="comment">//移除成功，拒绝该非运行的任务</span></span><br><span class="line">            reject(command);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="comment">//防止了SHUTDOWN状态下没有活动线程了，但是队列里还有任务没执行这种特殊情况。</span></span><br><span class="line">            <span class="comment">//添加一个null任务时因为SHUTDOWN状态下，线程池不再接受新任务</span></span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!addWorker(command, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        	<span class="comment">//如果队列满了或者是非运行的任务都拒绝执行</span></span><br><span class="line">        	reject(command);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>然后是addWorker源码分析：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    	<span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">//获取当前线程状态</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">        <span class="keyword">if</span>(rs &gt;= SHUTDOWN &amp;&amp; !(rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span> &amp;&amp; !workQueue.isEmpty()))</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">            	<span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">                <span class="comment">//如果超出容量或者最大线程池容量不在接受新任务</span></span><br><span class="line">                <span class="keyword">if</span>(wc &gt;= CAPACITY || wc &gt;= (core? corePoolSize: maximumPoolSize))</span><br><span class="line">                	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//CAS锁增加工作线程数</span></span><br><span class="line">                <span class="keyword">if</span>(compareAndIncrementWorkerCount(c))</span><br><span class="line">                	<span class="keyword">break</span> retry;</span><br><span class="line">            	c = ctl.get();</span><br><span class="line">                <span class="keyword">if</span>(runStateOf(c) != rs) &#123;</span><br><span class="line">                	<span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>核心代码就是如上所述，当然还有一些关闭之类和饱和策略处理的代码工作，有兴趣再去阅读</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2016/06/03/java线程池解析/" data-id="cjyms8jt5000kdwudma161a1f" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java主线程监控子线程策略解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2016/06/03/java主线程监控子线程策略解析/" class="article-date">
  <time datetime="2016-06-03T13:04:41.000Z" itemprop="datePublished">2016-06-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2016/06/03/java主线程监控子线程策略解析/">Java UncaughtExceptionHandler（处理子线程异常）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>主要针对于多线程编程时，出现工作线程异常中断时，可以优雅地记录下异常日志。</p>
<p>Java的异常可以分为<font color="red">Checked Exceptions</font>和<font color="red">Unchecked Exceptions</font>。</p>
<p>第二类异常，调用某些方法时，api也提示了可能会抛出某些异常，但该类异常不是一定要捕获的。</p>
<p>不需要进行try catch也能执行，如果出错，只会在控制台打印，很难查找问题。</p>
<p>所以Java提供了针对于第二类异常问题的处理方法：UncaughtExceptionHandler，对于未知异常的处理。</p>
<p>简单使用一下UncaughtExceptionHandler：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyExceptionHandler</span> <span class="keyword">implements</span> <span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">"Exception begin!"</span>);</span><br><span class="line">        </span><br><span class="line">        ...doSomething...</span><br><span class="line">        </span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后将此异常处理的实例赋值给所建线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> T1());</span><br><span class="line">thread.setUncaughtExceptionHandler(<span class="keyword">new</span> MyExceptionHandler());</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2016/06/03/java主线程监控子线程策略解析/" data-id="cjyms8jt0000jdwudzbn6ynek" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java类加载器原理详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2016/01/02/Java类加载器原理详解/" class="article-date">
  <time datetime="2016-01-02T07:01:55.000Z" itemprop="datePublished">2016-01-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2016/01/02/Java类加载器原理详解/">Java类加载器原理详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>同样先提出几个问题：</p>
<hr>
<p>1.Java类加载机制（双亲委派模式）是什么？</p>
<hr>
<p>2.为什么要使用双亲委派模式？</p>
<hr>
<p>3.双亲委派模式是否能被破坏？</p>
<hr>
<p>首先说下类加载器的基本概念：用来加载Java类到Java虚拟机中。类加载器负责读取Java字节代码，并转换成java.lang.Class类的一个实例。</p>
<p>首先上一双亲委派模式图：</p>
<p><div id="flowchart-0" class="flow-chart"></div><br>白话一点，双亲委派机制就是加载一个类时，首先子类加载器会委托给父类加载器进行试加载，父类加载器若还有父类，那么继续向上委托，若最上层父类加载器不能加载，然后向下开始进行子类加载。</p>
<p>配合上面描述，先了解一个类。</p>
<h5 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h5><p>ClassLoader类是一个抽象类，它定义了类加载器的基本方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明   </th>
</tr>
</thead>
<tbody>
<tr>
<td>getParent()</td>
<td>返回该类加载器的父类加载器</td>
</tr>
<tr>
<td>loadClass(String name)</td>
<td>加载名称为name的类，返回的结果是java.lang.Class类的实例。 </td>
</tr>
<tr>
<td>findClass(String name)</td>
<td>查找名称为name的类，返回的结果是java.lang.Class类的实例。 </td>
</tr>
<tr>
<td>findLoadedClass(String name)</td>
<td>查找名称为name的已经被加载过的类，返回的结果是java.lang.Class类的实例。</td>
</tr>
<tr>
<td>defineClass(String name,byte[] b,int off,int len)</td>
<td>把字节数组b中的内容转换成Java类，返回的结果是java.lang.Class类的实例。这个方法被声明为final的。</td>
</tr>
</tbody>
</table>
<p>其中loadClass方法定义了双亲委派模式机制的运行原理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)&#123;</span><br><span class="line">    Class c = findLoadedClass(name);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//使用父加载器加载此类</span></span><br><span class="line">            c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果父加载器没有成功加载，则自己尝试加载</span></span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析到这里，已经解释了什么是双亲委派机制，<font color="red">如果要破坏双亲委派机制该做什么呢？只需要将loadClass()方法重新定义就好了</font>，但不建议如此去做，下面解释一下Java为什么要使用双亲委派机制去加载类。</p>
<h4 id="双亲委派机制的原因"><a href="#双亲委派机制的原因" class="headerlink" title="双亲委派机制的原因"></a>双亲委派机制的原因</h4><p>首先需要明确两点：</p>
<p>1.jvm如何认定两个对象同属于一个类型，必须同时满足下面两个条件：</p>
<p>. 都是用同名的类完成实例化的。<br>. 两个实例各自对应的同名的类的加载器必须是同一个。</p>
<p>2.所以，为了系统类的安全，类似Object这种核心类，jvm需要保证他们生成的对象都会被认定为同一种类型。</p>
<p>好了，这两点充分说明，<font color="red">定义此种机制是为了安全，使用户在使用默认加载器的情况下无法改变核心类的加载方式,当然，这句话说得有点偏激，但还是建议不要通过自定义加载器改写loadClass()的方法打破双亲委派模式。</font><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">op1=>operation: Bootstrap Class Loader
op2=>operation: Extension Class Loader
op3=>operation: System Class Loader
op4=>operation: User-Defined Class Loader

op4(right)->op3(right)->op2(right)->op1(right)</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2016/01/02/Java类加载器原理详解/" data-id="cjyms8jrs0009dwuduhzlg7p1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/lfhboke.github.io/page/3/">&laquo; Prev</a><a class="page-number" href="/lfhboke.github.io/">1</a><a class="page-number" href="/lfhboke.github.io/page/2/">2</a><a class="page-number" href="/lfhboke.github.io/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/lfhboke.github.io/page/5/">5</a><a class="extend next" rel="next" href="/lfhboke.github.io/page/5/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2016/01/">January 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/lfhboke.github.io/2019/07/27/netty入门应用/">netty入门应用</a>
          </li>
        
          <li>
            <a href="/lfhboke.github.io/2019/07/21/netty开篇/">netty开篇</a>
          </li>
        
          <li>
            <a href="/lfhboke.github.io/2019/07/14/web-xml配置文件详解/">web.xml配置文件详解</a>
          </li>
        
          <li>
            <a href="/lfhboke.github.io/2019/07/14/spring过滤器/">spring过滤器</a>
          </li>
        
          <li>
            <a href="/lfhboke.github.io/2019/07/14/spring拦截器HandlerInterceptor/">spring拦截器HandlerInterceptor</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 lfhu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/lfhboke.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="/lfhboke.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/lfhboke.github.io/fancybox/jquery.fancybox.css">
  <script src="/lfhboke.github.io/fancybox/jquery.fancybox.pack.js"></script>


<script src="/lfhboke.github.io/js/script.js"></script>



  </div>
</body>
</html>