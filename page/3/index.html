<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>lfh&#39;s bokes</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="lfh&#39;s bokes">
<meta property="og:url" content="https://linfordhu.github.io/lfhboke.github.io/page/3/index.html">
<meta property="og:site_name" content="lfh&#39;s bokes">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lfh&#39;s bokes">
  
    <link rel="alternate" href="/lfhboke.github.io/atom.xml" title="lfh&#39;s bokes" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/lfhboke.github.io/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/lfhboke.github.io/" id="logo">lfh&#39;s bokes</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/lfhboke.github.io/">Home</a>
        
          <a class="main-nav-link" href="/lfhboke.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/lfhboke.github.io/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://linfordhu.github.io/lfhboke.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-深入理解读写锁ReadWriteLock源码" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2017/06/25/深入理解读写锁ReadWriteLock源码/" class="article-date">
  <time datetime="2017-06-25T14:06:42.000Z" itemprop="datePublished">2017-06-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2017/06/25/深入理解读写锁ReadWriteLock源码/">深入理解读写锁ReadWriteLock源码</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>ReadWriteLock管理一组锁，一个是只读锁，一个是写锁。读锁可以在没有写锁的时候被多个线程同时持有，写锁是独占的。<br>所有读写锁的实现必须确保写操作对读操作的内存影响。换句话说，一个获得了读锁的线程必须能看到前一个释放的写锁所更新的内容。<br>读写锁比互斥锁允许对于共享数据更大程度的并发。每次只能有一个写线程，但是同时可以有多个线程并发地读数据。ReadWriteLock适用于读多写少的并发情况。<br>Java并发包中ReadWriteLock是一个接口，主要有两个方法，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span></span>&#123;</span><br><span class="line">	<span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Java并发库中ReetrantReadWriteLock实现了ReadWriteLock接口并添加了可重入的特性。</p>
<h3 id="ReetrantReadWriteLock分析"><a href="#ReetrantReadWriteLock分析" class="headerlink" title="ReetrantReadWriteLock分析"></a>ReetrantReadWriteLock分析</h3><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>ReentrantReadWriteLock有如下特性：</p>
<pre><code>获取顺序
1. 非公平模式
当以非公平初始化时，读锁和写锁的获取的顺序是不确定的。非公平锁主张竞争获取，可能会延缓一个或多个读或写线程，但是会比公平锁有更高的吞吐量。
2. 公平模式
当以公平模式初始化时，线程将会以队列的顺序获取锁。当当前线程释放锁后，等待时间最长的写锁线程就会被分配写锁；或者有一组读线程组等待时间比写线程长，那么这组读线程组将会被分配读锁。
当有写线程持有写锁或者等待的写线程时，一个尝试获取公平的读锁（非重入）的线程就会阻塞。这个线程直到等待时间最长的写锁获得锁后并释放掉锁后才能获取到读锁。

可重入
允许读锁和写锁可重入。写锁可以获得读锁，读锁不能获得写锁。

锁降级
允许写锁降低为读锁

中断锁的获取
在读锁和写锁的获取过程中支持中断

支持Condition
写锁提供Condition实现

监控
提供确定锁是否被持有等辅助方法
</code></pre><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p>ReentrantReadWriteLock有两个构造方法，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">	sync = fair? <span class="keyword">new</span> FairSync(): <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">    writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，默认的构造方法使用的是非公平模式，创建的Sync是NonfairSync对象，然后初始化读锁和写锁。一旦初始化后，ReadWriteLock接口中的两个方法就有返回值了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">WriteLock <span class="title">writeLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> writerLock;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">ReadLock <span class="title">readLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> readerLock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看到，构造方法决定了Sync是FairSync还是NonfairSync。Sync继承了AbstractQueuedSynchronizer，而Sync是一个抽象类，NonfairSync和FairSync继承了Sync，并重写了其中的抽象方法。</p>
<h5 id="Sync分析"><a href="#Sync分析" class="headerlink" title="Sync分析"></a>Sync分析</h5><p>Sync中提供了很多方法，但是有两个方法是抽象的，子类必须实现。下面以FairSync为例，分析一下这两个抽象方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>writerShouldBlock和readerShouldBlock方法都表示当有别的线程也在尝试获取锁时，是否应该阻塞。<br>对于公平模式，hasQueuedPredecessors()方法表示前面是否有等待线程。一旦前面有等待线程，那么为了遵循公平，当前线程也就应该被挂起。<br>下面再来看NonfairSync的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看到，非公平模式下，writerShouldBlock直接返回false，说明不需要阻塞；而readShouldBlock调用了apparentFirstQueuedIsExclusive()方法。该方法在当前线程是写锁占用的线程时，返回true；否则返回false。也就说明，如果当前有一个写线程正在写，那么该读线程应该阻塞。<br>继承AQS的类都需要使用state变量代表某种资源，ReentrantReadWriteLock中的state代表了读锁的数量和写锁的持有与否，整个结构如下：<br><img src="/lfhboke.github.io/css/images/readwrite.PNG" alt="readwrite"><br>可以看到state的高16位代表读锁的个数；低16位代表写锁的状态。</p>
<h4 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h4><h5 id="读锁的获取"><a href="#读锁的获取" class="headerlink" title="读锁的获取"></a>读锁的获取</h5><p>当需要使用读锁时，首先调用lock方法，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从代码可以看到，读锁使用的是AQS的共享模式，AQS的acquireShared方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(tryAcquireShared(arg)&lt;<span class="number">0</span>)</span><br><span class="line">	doAcquireShared(arg);</span><br></pre></td></tr></table></figure></p>
<p>当tryAcquireShared()方法小于0时，那么会执行doAcquireShared方法将该线程加入到等待队列中。Sync实现了tryAcquireShared方法，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">	Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//如果当前有写线程并且本线程不是写线程，不符合重入，失败</span></span><br><span class="line">    <span class="keyword">if</span>(exclusiveCount(c) != <span class="number">0</span> &amp;&amp; getExclusiveOwnerThread() != current)</span><br><span class="line">    	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//得到读锁的个数</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    <span class="comment">//如果读不应该阻塞并且读锁的个数小于最大值65535，并且可以成功更新状态值，成功</span></span><br><span class="line">    <span class="keyword">if</span>(!readerShouldBlock() &amp;&amp; r &lt; MAX_COUNT &amp;&amp; compareAndSetState(c, c+SHARED_UNIT)) &#123;</span><br><span class="line">    	<span class="comment">//如果当前读锁为0</span></span><br><span class="line">        <span class="keyword">if</span>(r == <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="comment">//第一个读线程就是当前线程</span></span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前线程重入了，记录firstReaderHoldCount</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(firstReader == current)</span><br><span class="line">        	firstReaderHoldCount++;</span><br><span class="line">      	&#125;</span><br><span class="line">        <span class="comment">//当前读线程和第一个读线程不同，记录每一个线程读的次数</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span>(rh==<span class="keyword">null</span>||rh.tid!=getThreadId(current))</span><br><span class="line">              cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的代码以及注释可以看到，分为三步</p>
<ol>
<li>如果当前有写线程并且本线程不是写线程，那么失败，返回-1。</li>
<li>否则，说明当前没有写线程或者本线程就是写线程（可重入），接下来判断是否应该读线程阻塞并且读锁的个数是否小于最小值，并且CAS成功使读锁+1。</li>
<li>如果2失败了，失败的原因有三，第一应该读线程应该阻塞；第二是因为读锁达到了上线；第三是因为CAS失败，有其他线程在并发更新state，那么会调用fullTryAcquireShared方法。</li>
</ol>
<p>fullTryAcquiredShared方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">	HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    	<span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">//一旦有别的线程获得了写锁，返回-1，失败</span></span><br><span class="line">        <span class="keyword">if</span>(exclusiveCount(c)!=<span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="keyword">if</span>(getExclusiveOwnerThread() != current)</span><br><span class="line">            	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果读线程需要阻塞</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(readerShouldBlock()) &#123;</span><br><span class="line">        	<span class="keyword">if</span>(firstReader == current) &#123;</span><br><span class="line">            	firstReaderHoldCount&gt;<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//说明有别的读线程占有了锁</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="keyword">if</span>(rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                	rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span>(rh == <span class="keyword">null</span>||rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                    	rh = readHolds.get();</span><br><span class="line">                        <span class="keyword">if</span>(rh.count = <span class="number">0</span>)</span><br><span class="line">                        	readHolds.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(rh.count == <span class="number">0</span>) </span><br><span class="line">                	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果读锁达到了最大值，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span>(sharedCount(c) == MAX_COUNT)</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">""</span>);</span><br><span class="line">        <span class="comment">//如果成功更改状态，成功返回</span></span><br><span class="line">        <span class="keyword">if</span>(compareAndSetState(c, c+SHARED_UNIT)) &#123;</span><br><span class="line">        	<span class="keyword">if</span>(sharedCount(c)==<span class="number">0</span>) &#123;</span><br><span class="line">            	firstReader = current;</span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(fistReader == current)&#123;</span><br><span class="line">            	firstReaderHoldCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="keyword">if</span>(rh == <span class="keyword">null</span>)</span><br><span class="line">                	rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span>(rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                	rh = readHolds.get();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                	readHolds.set(rh);</span><br><span class="line">                rh.count++;</span><br><span class="line">                cachedHoldCounter = rh;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="写锁的获取"><a href="#写锁的获取" class="headerlink" title="写锁的获取"></a>写锁的获取</h5><p>写锁是独占锁，ReetrantLock分析过，此处就不再赘述。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><pre><code>如果当前没有写锁或读锁时，第一个获取锁的线程都会成功，无论该锁是写锁还是读锁。
如果当前已经有了读锁，那么这时获取写锁将失败，获取读锁有可能成功也有可能失败
如果当前已经有了写锁，那么这时获取读锁或写锁，如果线程相同（可重入），那么成功；否则失败。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2017/06/25/深入理解读写锁ReadWriteLock源码/" data-id="cjyms8jw70012dwud31q48r9s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java多线程之Future模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2017/06/24/Java多线程之Future模式/" class="article-date">
  <time datetime="2017-06-24T15:57:45.000Z" itemprop="datePublished">2017-06-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2017/06/24/Java多线程之Future模式/">Java多线程之Future模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException,ExecutionException </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> s = state;</span><br><span class="line">	<span class="keyword">if</span>(s &lt;= COMPLETING) &#123;</span><br><span class="line">		s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">long</span> deadline = timed? System.nanoTime() + nanos: <span class="number">0L</span>;</span><br><span class="line">	WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(;;) &#123;</span><br><span class="line">		<span class="keyword">if</span>(Thread.interrupted()) &#123;</span><br><span class="line">		removeWaiter(q);</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> s = state;</span><br><span class="line">	<span class="keyword">if</span>(s &gt; COMPLETING) &#123;</span><br><span class="line">		<span class="keyword">if</span>(q != <span class="keyword">null</span>) &#123;</span><br><span class="line">			q.thread = <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) &#123;</span><br><span class="line">		Thread.yield();</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(q == <span class="keyword">null</span>) &#123;</span><br><span class="line">		q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(!queued) &#123;</span><br><span class="line">		queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,q.next=waiters,q);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">		nanos = deadline - System.nanoTime();</span><br><span class="line">		<span class="keyword">if</span>(nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">			removeWaiter(q);</span><br><span class="line">			<span class="keyword">return</span> state;</span><br><span class="line">		&#125;</span><br><span class="line">		LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果call方法的执行过程已完成，就把结果给出去；如果未完成，就将当前线程挂起等待。<br>挂起的线程何时被唤醒；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(WaitNode q; (q=waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">		<span class="keyword">if</span>(UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,q,<span class="keyword">null</span>)) &#123;</span><br><span class="line">			<span class="keyword">for</span>(;;)&#123;</span><br><span class="line">				Thread t = q.thread;</span><br><span class="line">				<span class="keyword">if</span>(t != <span class="keyword">null</span>) &#123;</span><br><span class="line">					q.thread = <span class="keyword">null</span>;</span><br><span class="line">					LockSupport.unpark(t);<span class="comment">//唤醒线程</span></span><br><span class="line">				&#125;</span><br><span class="line">				WaitNode next = q.next;</span><br><span class="line">				<span class="keyword">if</span>(next == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				q.next = <span class="keyword">null</span>;</span><br><span class="line">				q = next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	done();</span><br><span class="line">	callable = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2017/06/24/Java多线程之Future模式/" data-id="cjyms8jri0007dwudo5es74ht" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java多线程之Condition条件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2017/06/23/Java多线程之Condition条件/" class="article-date">
  <time datetime="2017-06-23T13:22:53.000Z" itemprop="datePublished">2017-06-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2017/06/23/Java多线程之Condition条件/">Java多线程之Condition条件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Condition介绍"><a href="#Condition介绍" class="headerlink" title="Condition介绍"></a>Condition介绍</h3><p>Condition的作用是对锁进行更精确的控制。Condition中的await()方法相当于Object的wait()方法，Condition中的signal()方法相当于Object的notify()方法，Condition中的signalAll()相当于Object的notifyAll()方法。不同的是，Object中的wait()，notify()，notifyAll()方法是和“同步锁”捆绑使用的；而Condition是需要与“互斥锁”/“共享锁”捆绑使用的。</p>
<h3 id="Condition函数列表"><a href="#Condition函数列表" class="headerlink" title="Condition函数列表"></a>Condition函数列表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//造成当前线程在接到信号或被中断之前一直处于等待状态。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function"><span class="comment">//造成当前线程在接到信号之前一直处于等待状态</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//造成当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span></span>;</span><br><span class="line"><span class="comment">// 唤醒一个等待线程。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//唤醒所有等待线程。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Condition实现原理分析"><a href="#Condition实现原理分析" class="headerlink" title="Condition实现原理分析"></a>Condition实现原理分析</h3><h4 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h4><p>创建一个condition对象是通过lock.newCondition(),而这个方法实际上是会new出一个ConditionObject对象，该类是AQS的一个内部类。condition是要和lock配合使用的，而lock的实现原理又依赖于AQS，自然而然ConditionObject作为AQS的一个内部类无可厚非。锁机制的实现上，AQS内部维护了一个同步队列，如果是独占式锁的话，所有获取锁失败的线程的队尾插入到同步队列，同样的，condition内部也是使用同样的方式，内部维护了一个等待队列，所有调用condition.await方法的线程会加入到等待队列中，并且线程状态转换为等待状态。另外注意到ConditionObject中有两个成员变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br></pre></td></tr></table></figure></p>
<p>可以看出来ConditionObject通过持有等待队列的头尾指针来管理等待队列。Node类有这样一个属性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后继节点</span></span><br><span class="line">Node nextWaiter;</span><br></pre></td></tr></table></figure></p>
<p>进一步说明，等待队列是一个单向队列，而在之前说AQS时知道同步队列是一个双向队列。</p>
<font color="red">可以调用lock.newCondition()方法创建多个condition对象，也就是一个lock可以持有多个等待队列。而在之前利用Object的方式实际上是指在对象Object对象监视器上只能拥有一个同步队列和一个等待队列，而并发包中的Lock拥有一个同步队列和多个等待队列。</font>

<h4 id="await实现原理"><a href="#await实现原理" class="headerlink" title="await实现原理"></a>await实现原理</h4><p>当调用condition.await()方法后会使得当前获取lock的线程进入到等待队列，如果该线程能够从await()方法返回的话一定是该线程获取了与condition相关联的lock。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Thread.interrupted())</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">//1.将当前线程包装成Node，尾插入到等待队列中</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">//2.释放当前线程所占用的lock，在释放的过程中hi唤醒同步队列中的下一个节点</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!isOnSyncQueue(node)) &#123;</span><br><span class="line">    	<span class="comment">//3.当前线程进入到等待状态</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span>((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.自旋等待获取到同步状态（即获取到lock）</span></span><br><span class="line">    <span class="keyword">if</span>(acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">    	interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span>(node.nextWaiter != <span class="keyword">null</span>) </span><br><span class="line">    	unlinkCancelledWaiters();</span><br><span class="line">    <span class="comment">//5.处理被中断的情况</span></span><br><span class="line">    <span class="keyword">if</span>(interruptMode != <span class="number">0</span>)</span><br><span class="line">    	reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码的主要逻辑请看注释，当当前线程调用condition.await()方法后，会使得当前线程释放lock然后加入到等待队列中，直至被signal/signalAll后会使得大哥前线程从等待队列中移至到同步队列中去，直到获得了lock后才会从await方法返回，或者在等待时被中断做中断处理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Node t = lastWaiter;</span><br><span class="line">    <span class="keyword">if</span>(t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">    	unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将当前线程包装成Node</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="keyword">null</span>)</span><br><span class="line">    	firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="comment">//尾插入</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    <span class="comment">//更新lastWaiter</span></span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将当前节点包装成Node，如果等待队列的firstWaiter为null的话（等待队列为空队列），则将firstWaiter指向当前的Node，否则，更新lastWaiter（尾节点）即可。就是通过尾插入的方式将当前线程封装的Node插入到等待独列中即可，同时可以看出等待队列是也不带头结点的链式队列。AQS同步队列是一个带头结点的链式队列，这是两者的一个区别。将当前节点插入到等待队列之后，会使当前线程释放lock，由fullyRelease方法实现，fullyRelease源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> savedState = getState();</span><br><span class="line">        <span class="keyword">if</span>(release(savedState)) &#123;</span><br><span class="line">        	<span class="comment">//成功释放同步状态</span></span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">//不成功释放同步状态抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用AQS的模板方法release释放AQS的同步状态并且唤醒在同步队列中头节点的后继节点引用的线程，如果释放成功则正常返回，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!isOnSyncQueue(node)) &#123;</span><br><span class="line">	LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span>((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">    	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当线程第一次调用condition.await()方法时，会进入到这个while()循环中，然后通过LockSupport.park(this)方法使得当前线程进入等待状态，那么要想退出这个await方法第一个前提条件自然而然的是要先退出这个while循环，第一种情况是当前等待线程被中断，第二种情况是当前节点被移动到了同步队列中。</p>
<h4 id="signal-signalAll实现原理"><a href="#signal-signalAll实现原理" class="headerlink" title="signal/signalAll实现原理"></a>signal/signalAll实现原理</h4><p>调用condition的signal或者signalAll方法可以将等待队列中等待时间最长的节点移动到同步队列中，使得该节点能够有机会获得lock。按照等待队列是先进先出（FIFO）的，所以等待队列的头节点必然会是等待时间最长的节点，也就是每次调用condition的signal方法是将头节点移动到同步队列中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1.先检测当前线程是否已经获取lock</span></span><br><span class="line">    <span class="keyword">if</span>(!isHeldExclusively())</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">    <span class="comment">//2.获取等待队列中第一个节点，之后的操作都是针对这个节点</span></span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span>(first != <span class="keyword">null</span>)</span><br><span class="line">    	doSignal(first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>((firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">        	lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//1.将头节点从等待队列中移除</span></span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//2.while中transferForSignal方法对头节点做真正的处理</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(!transferForSignal(first) &amp;&amp; (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1.更新状态为0</span></span><br><span class="line">    <span class="keyword">if</span>(!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.将该节点移入到同步队列中去</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="keyword">if</span>(ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">    	LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2017/06/23/Java多线程之Condition条件/" data-id="cjyms8jr50004dwud67eiiywf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java多线程之BlockingQueue（2）ArrayBlockingQueue" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2017/06/23/Java多线程之BlockingQueue（2）ArrayBlockingQueue/" class="article-date">
  <time datetime="2017-06-23T07:39:23.000Z" itemprop="datePublished">2017-06-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2017/06/23/Java多线程之BlockingQueue（2）ArrayBlockingQueue/">Java多线程之BlockingQueue（2）ArrayBlockingQueue</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="属性变量："><a href="#属性变量：" class="headerlink" title="属性变量："></a>属性变量：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 队列元素存放数组</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items;</span><br><span class="line">    <span class="comment">// 获取元素的数组下标</span></span><br><span class="line">    <span class="keyword">int</span> takeIndex;</span><br><span class="line">    <span class="comment">// 插入元素的数组下标</span></span><br><span class="line">    <span class="keyword">int</span> putIndex;</span><br><span class="line">    <span class="comment">// 元素数量</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">// 线程锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">    <span class="comment">// 非空条件(获取元素)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line">    <span class="comment">// 非满条件（可以插入）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到使用数组来保存元素。takeIndex是队首下标，putIndex是队尾下标，count是队列中元素数目。lock是一个可重入锁，notEmpty和notFull是等待条件。</p>
<h4 id="构造函数："><a href="#构造函数：" class="headerlink" title="构造函数："></a>构造函数：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定大小的队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//指定大小和公平性的队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//指定大小和公平性并使用已有的集合构建</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair, Collection&lt;? extends E&gt; c)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="put和take的实现方式："><a href="#put和take的实现方式：" class="headerlink" title="put和take的实现方式："></a>put和take的实现方式：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">	checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">    	<span class="keyword">while</span>(count == items.length) &#123;</span><br><span class="line">        	notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    	lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkNotNull</span><span class="params">( Object v )</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(v == <span class="keyword">null</span>) &#123;</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="keyword">if</span>(++putIndex == items.length)</span><br><span class="line">    	putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先获取锁，判断当前队列是否满，满则阻塞，被其他线程唤醒时插入元素，插入成功后通过notEmpty.signal()唤醒因队列为空等待取元素的线程。最后释放锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">    	<span class="keyword">while</span>(count == <span class="number">0</span>)</span><br><span class="line">        	notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    	lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(++takeIndex==item.length)</span><br><span class="line">    	takeIndex=<span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span>(itrs != <span class="keyword">null</span>)</span><br><span class="line">    	itrs.elementDequeued();</span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2017/06/23/Java多线程之BlockingQueue（2）ArrayBlockingQueue/" data-id="cjyms8jr90005dwudotcu176h" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java多线程之BlockingQueue" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2017/06/23/Java多线程之BlockingQueue/" class="article-date">
  <time datetime="2017-06-23T05:02:18.000Z" itemprop="datePublished">2017-06-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2017/06/23/Java多线程之BlockingQueue/">Java多线程之BlockingQueue（1）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>阻塞队列与非阻塞队列一个最大的区别就是：阻塞队列能够阻塞当前试图从队列中获取元素的线程，而非阻塞队列不会。因此在面对类似消费者——生产者的模型时，使用非阻塞队列就必须额外地实现同步策略以及线程间唤醒策略，这个实现起来就非常麻烦。但是有了阻塞队列就不一样了，它会对当前线程产生阻塞，比如一个线程从一个空的阻塞队列中取元素，此时线程会被阻塞直到阻塞队列中有了元素。当队列中有元素后，被阻塞的线程会自动被唤醒。</p>
<h3 id="JDK中的阻塞队列概况"><a href="#JDK中的阻塞队列概况" class="headerlink" title="JDK中的阻塞队列概况"></a>JDK中的阻塞队列概况</h3><p>阻塞队列由BlockingQueue进行定义。在JDK1.8中实现了该接口的主要有以下几个：<br>ArrayBlockingQueue——基于数组实现的一个阻塞队列，在创建ArrayBlockingQueue对象时必须制定容量大小。并且可以指定公平性与非公平性，默认情况下为非公平的，即不保证等待时间最长的线程最优先能够访问队列。<br>LinkedBlockingQueue——基于链表实现的一个阻塞队列，在创建LinkedBlockingQueue对象时如果不指定容量大小，则默认大小为Integer.MAX_VALUE。<br>PriorityBlockignQueue——无界阻塞队列，它会按照元素的优先级对元素进行排序，按照优先级顺序出队，每次出队的元素都是优先级最高的元素。<br>DelayQueue——基于PriorityQueue实现的延迟队列，是一个无界阻塞队列，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。因此向队列中插入时永远不会阻塞，获取时才有可能被阻塞。<br>SynchronousQueue——同步阻塞队列，队列大小为1，一个元素要放到该队列中必须有一个线程在等待获取元素。<br>DelayedWorkQueue——该队列为ScheduledThreadPoolExecutor中的静态内部类，ScheduledThreadPoolExecuor便是通过该队列使得队列中的元素按一定顺序从而使延迟任务和周期性任务得以顺利执行。<br>BlockingDeque——双向阻塞队列的接口。<br>TransferQueue——接口，定义了另一种阻塞情况：生产者会一直阻塞直到所添加到队列的元素被某一个消费者所消费，而BlockingQueue只需将元素添加到队列后生产者便会停止被阻塞。</p>
<h3 id="阻塞队列与非阻塞队列中的方法对比"><a href="#阻塞队列与非阻塞队列中的方法对比" class="headerlink" title="阻塞队列与非阻塞队列中的方法对比"></a>阻塞队列与非阻塞队列中的方法对比</h3><h4 id="非阻塞队列常用方法"><a href="#非阻塞队列常用方法" class="headerlink" title="非阻塞队列常用方法"></a>非阻塞队列常用方法</h4><p>在非阻塞队列中常用的操作队列的方法主要是下面几种：<br>add(E e)：将元素e插入到队列末尾，如果插入成功，则返回true；如果插入失败（即队列已满），则会抛出异常；<br>remove()：移除队首元素，若移除成功，则返回true；如果失败，抛出异常；<br>offer(E e)：将元素e插入到队列末尾，如果插入成功，则返回true；如果插入失败（即队列已满），则返回false；<br>poll()：移除并获取队首元素，若成功，则返回队首元素；否则返回null；<br>peek()：获取队首元素，但不移除。若成功，则返回队首元素；否则返回null</p>
<p>对于非阻塞队列，一般情况下建议使用offer、poll和peek三个方法，不建议使用add和remove方法。原因看上面的描述很明显了：add和remove方法需要捕获异常才能判断操作成功与否。另外需要注意非阻塞队列的这些方法都没有进行同步处理。</p>
<h4 id="阻塞队列常用方法"><a href="#阻塞队列常用方法" class="headerlink" title="阻塞队列常用方法"></a>阻塞队列常用方法</h4><p>阻塞队列也实现了Queue，因此也具有上述方法并且都进行了同步处理。除此之外还有4个很有用的方法：<br>put(E e)：向队尾存入元素，如果队列满，则等待；<br>take()：从队首取元素，如果队列为空，则等待；<br>offer(E e, long timeout, TimeUnit unit)：向队尾存入元素，如果队列满，则等待一定的时间，当时间期限达到时，如果还没有插入成功，则返回false；否则返回true；<br>poll(long timeout,TimeUnit unit)：从队首取元素，如果队列空，则等待一定时间，当时间期限达到时，如果取不到，则返回null；</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2017/06/23/Java多线程之BlockingQueue/" data-id="cjyms8jrd0006dwudtjw8hby9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据库设计的三大范式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2017/06/23/数据库设计的三大范式/" class="article-date">
  <time datetime="2017-06-23T03:43:42.000Z" itemprop="datePublished">2017-06-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2017/06/23/数据库设计的三大范式/">数据库设计的三大范式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>什么是范式：简而言之就是，数据库设计对数据存储性能，还有开发人员对数据的操作都有莫大的关系。所以建立科学的，规范的数据库是需要满足一些规范来优化数据存储方式。</p>
<h3 id="三大范式概念"><a href="#三大范式概念" class="headerlink" title="三大范式概念"></a>三大范式概念</h3><p>第一范式：当关系模式R的所有属性都不能在分解为更基本的数据单位时，称R是满足第一范式的，简记为1NF。满足第一范式是关系模式规范化的最低要求，否则，将有很多基本操作在这样的关系模式中实现不了。<br>第二范式：如果关系模式R满足第一范式，并且R的所有非主属性都完全依赖于R的每一个候选关键属性，称R满足第二范式，简记为2NF。<br>第三范式：设R是一个满足第一范式条件的关系模式，X是R的任意属性集，如果X非传递依赖于R的任意一个候选关键字，称R满足第三范式，3NF。</p>
<h3 id="理解三大范式"><a href="#理解三大范式" class="headerlink" title="理解三大范式"></a>理解三大范式</h3><h4 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h4><ol>
<li>每一列属性都是不可再分的属性值，确保每一列的原子性</li>
<li>两列的属性相近或相似或一样，尽量合并属性一样的列，确保不产生冗余数据。</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>Name</th>
<th>Code</th>
<th>DataType</th>
<th>Length</th>
<th>Precision</th>
<th>P</th>
</tr>
</thead>
<tbody>
<tr>
<td> 1</td>
<td>留言编号</td>
<td>MsgId</td>
<td>int</td>
<td></td>
<td></td>
<td>true</td>
</tr>
<tr>
<td> 2</td>
<td>留言人姓名</td>
<td>Name</td>
<td>varchar(30)</td>
<td>30</td>
<td></td>
<td>false</td>
</tr>
<tr>
<td> 3</td>
<td>地址</td>
<td>Address</td>
<td>varchar(80)</td>
<td>80</td>
<td></td>
<td>false</td>
</tr>
</tbody>
</table>
<p> 如果需求直到那个省哪个市并按其分类，那么显然第一个表格不容易满足需求的，也不符合第一范式。</p>
<h4 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h4><p> 每一行的数据只能与其中一列相关，即一行数据只做一件事。只要数据列中出现数据重复，就要把表拆分开来。</p>
<h4 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h4><p> 数据不能存在传递关系，即每个属性都跟主键有直接关系而不是间接关系。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2017/06/23/数据库设计的三大范式/" data-id="cjyms8jtl000pdwudzf7qin5q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JDk动态代理与CGLIB动态代理的区别以及它们实现原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2017/06/22/JDk动态代理与CGLIB动态代理的区别以及它们实现原理/" class="article-date">
  <time datetime="2017-06-22T12:34:02.000Z" itemprop="datePublished">2017-06-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2017/06/22/JDk动态代理与CGLIB动态代理的区别以及它们实现原理/">JDK动态代理与CGLIB动态代理的区别以及它们实现原理（1）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前已经在github上传入了JDK动态代理和CGLIB动态代理的例子，现在开始深究其区别以及实现原理。</p>
<h3 id="JDK动态代理实现原理"><a href="#JDK动态代理实现原理" class="headerlink" title="JDK动态代理实现原理"></a>JDK动态代理实现原理</h3><p>JDK动态代理其实是基于接口实现的。因为通过接口指向实现类实例的多态方式，可以有效地将具体实现与调用解耦，便于后期的修改和维护。</p>
<p>JDK动态代理是利用反射机制在运行时创建代理类。核心是InvocationHandler。每一个代理的实例都会有一个关联的调用处理程序（InvocationHandler）。对待代理实例进行调用时，将对方法的调用进行编码并指派到它的调用处理器的invoke方法。所以对代理对象实例方法的调用都是通过InvocationHandler中的invoke方法来完成的，而invoke方法会根据传入的代理对象、方法名称以及参数决定调用代理的哪个方法。</p>
<p>通过Proxy类中的newProxyInstance来完成的，看下函数源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt; interfaces, InvocationHandler h)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">	<span class="comment">//如果h为空将抛出异常</span></span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//拷贝被代理类实现的一些接口，用于后面权限方面的检查</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">    <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span>(sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">    	<span class="comment">//在这里对某些安全权限进行检查，确保我们有权限对预期的被代理类进行代理</span></span><br><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面这个方法将产生代理类</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用指定的调用处理程序获取代理类的构造函数对象</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">    	<span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        	checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">        <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">        <span class="comment">//假如代理类的构造函数是private的，就使用反射来set accessible</span></span><br><span class="line">        <span class="keyword">if</span>(!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">        	AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;()&#123;</span><br><span class="line">            	<span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                	cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据代理类的构造函数来生成代理类的对象并返回</span></span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以代理类其实是通过getProxyClass方法来生成的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成一个代理类，但是在调用本方法之前必须进行权限检查</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line"> 	<span class="comment">//如果接口数量大于65535，抛出非法参数错误</span></span><br><span class="line">    <span class="keyword">if</span>(interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果在缓存中有对应的代理类，那么直接返回</span></span><br><span class="line">    <span class="comment">//否则代理类将有ProxyClassFactory来创建</span></span><br><span class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 里面有一个根据给定ClassLoader和Interface来创建代理类的工厂函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; &#123;</span><br><span class="line"> 	<span class="comment">//代理类的名字的前缀统一为“$Proxy”</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">"$Proxy"</span>;</span><br><span class="line">    <span class="comment">//每个代理类前缀后面都会跟着一个唯一的编号，如$Proxy0;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextUniqueNumber = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line">    	Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces, length);</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; intf: interfaces) &#123;</span><br><span class="line">        	<span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 验证类加载器加载接口得到对象是否与由apply函数参数传入的对象相同</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">             Class&lt;?&gt; interfaceClass;</span><br><span class="line">             <span class="keyword">try</span>&#123;</span><br><span class="line">             	interfaceClass = Class.forName(intf.getName(), <span class="keyword">false</span>, loader);</span><br><span class="line">             &#125;<span class="keyword">catch</span>()&#123;&#125;</span><br><span class="line">             <span class="keyword">if</span>(interfaceClass != intf) &#123;</span><br><span class="line">             	<span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment">              * 验证这个接口是否重复</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">              <span class="keyword">if</span>(interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="keyword">true</span>) &#123;</span><br><span class="line">              	<span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//声明代理类所在的package</span></span><br><span class="line">              String proxyPkg = ;</span><br><span class="line">              <span class="keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line">              </span><br><span class="line">              <span class="comment">/*</span></span><br><span class="line"><span class="comment">               *记录一个非公共代理接口的包，以便在同一个包中定义代理类。同时验证所有代理接口都在同一个包中</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">               <span class="keyword">for</span> (Class&lt;?&gt; intf: interfaces) &#123;</span><br><span class="line">               	<span class="keyword">int</span> flags = intf.getModifiers();</span><br><span class="line">                <span class="keyword">if</span>(!Modifier.isPublic(flags)) &#123;</span><br><span class="line">                	accessFlags = Modifier.FINAL;</span><br><span class="line">                    String name = intf.getName();</span><br><span class="line">                    <span class="keyword">int</span> n = name.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">                    String pkg = ((n == -<span class="number">1</span>) ? <span class="string">""</span>: name.substring(<span class="number">0</span>, n+<span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">if</span>(proxyPkg == ) &#123;</span><br><span class="line">                    	proxyPkg = pkg;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">/*</span></span><br><span class="line"><span class="comment">                *为代理类生成一个name，package name + 前缀 + 唯一编号，如com.sun.proxy.$Proxy0.class</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">                String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 生成指定代理类的字节码文件</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                 <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</span><br><span class="line">                 <span class="keyword">try</span>&#123;</span><br><span class="line">                 	<span class="keyword">return</span> defineClass0(loader, proxyName, proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">                 &#125; <span class="keyword">catch</span>()&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>由上述代码，其实生成代理类字节码的工作是通过ProxyGenerate类中的generateProxyClass方法来完成的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] generateProxyClass(<span class="keyword">final</span> String var0, Class&lt;?&gt;[] var1, <span class="keyword">int</span> var2) &#123;</span><br><span class="line">	ProxyGenerator var3 = <span class="keyword">new</span> ProxyGenerator(var0, var1, var2);</span><br><span class="line">    <span class="comment">//真正用来生成代理类字节码文件的方法在这里</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] var4 = var3.generateClassFile();</span><br><span class="line">    <span class="comment">//保存代理类的字节码文件</span></span><br><span class="line">    <span class="keyword">if</span>(saveGeneratedFiles) &#123;</span><br><span class="line">    	AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction()&#123;</span><br><span class="line">        	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            	<span class="keyword">try</span>&#123;</span><br><span class="line">                	<span class="keyword">int</span> var1 = var0.lastIndexOf(<span class="number">46</span>);</span><br><span class="line">                    Path var2;</span><br><span class="line">                    <span class="keyword">if</span>(var1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    	Path var3 = Paths.get(var0.substring(<span class="number">0</span>,var1).replace(<span class="string">'.'</span>, File.separatorChar), <span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">                        Files.createDirectories(var3, <span class="keyword">new</span> FileAttribute[<span class="number">0</span>]);</span><br><span class="line">                        var2 = var3.resolve(var0.substring(var1 + <span class="number">1</span>, var0.length()) + <span class="string">".class"</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    	var2 = Paths.get(var0 + <span class="string">".class"</span>, <span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    Files.write(var2, var4, <span class="keyword">new</span> OpenOption[<span class="number">0</span>]);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;<span class="keyword">catch</span>()&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> var4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终来看看真正用于生成代理类字节码文件的generateClassFile方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] generateClassFile() &#123;</span><br><span class="line">	<span class="comment">//下面一系列的addProxyMethod方法是将接口中的方法和Object中的方法添加到代理方法中（proxyMethod）</span></span><br><span class="line">    <span class="keyword">this</span>.addProxyMethod(hashCodeMethod, Object.class);</span><br><span class="line">    <span class="keyword">this</span>.addProxyMethod(equalsMethod, Object.class);</span><br><span class="line">    <span class="keyword">this</span>.addProxyMethod(toStringMethod, Object.class);</span><br><span class="line">    Class[] var1 = <span class="keyword">this</span>.interfaces;</span><br><span class="line">    <span class="keyword">int</span> var2 = var1.length;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> var3;</span><br><span class="line">    Class var4;</span><br><span class="line">    <span class="comment">//获得接口中所有方法并添加到代理方法中</span></span><br><span class="line">    <span class="keyword">for</span> (var3 = <span class="number">0</span>; var3 &lt; <span class="keyword">var</span> <span class="number">2</span>; ++var3) &#123;</span><br><span class="line">    	var4 =var1[var3];</span><br><span class="line">        Method[] var5 = var4.getMethods();</span><br><span class="line">        <span class="keyword">int</span> var6 = var5.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var7 = <span class="number">0</span>; var7&lt; var6; ++var7) &#123;</span><br><span class="line">        	Method var8 = var5[var7];</span><br><span class="line">            <span class="keyword">this</span>.addProxyMethod(var8, var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Iterator var11 = <span class="keyword">this</span>.proxyMethods.values().iterator();</span><br><span class="line">    <span class="comment">//验证具有相同方法签名的方法的返回类型是否一致</span></span><br><span class="line">    List var12;</span><br><span class="line">    <span class="keyword">while</span>(var11.hasNext()) &#123;</span><br><span class="line">    	var12 = (List)var11.next();</span><br><span class="line">        checkReturnTypes(var12);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//后面一系列的步骤用于写代理类class文件</span></span><br><span class="line">    Iterator var15;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">    	<span class="comment">//生成代理类的构造函数</span></span><br><span class="line">    	<span class="keyword">this</span>.methods.add(<span class="keyword">this</span>.generateConstructor());</span><br><span class="line">        var11 = <span class="keyword">this</span>.proxyMethods.values().iterator();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(var11.hasNext()) &#123;</span><br><span class="line">        	var12 = (List)var11.next();</span><br><span class="line">            var15 = var12.iterator();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(var15.hasNext()) &#123;</span><br><span class="line">            	ProxyGenerator.ProxyMethod var16 = (ProxyGenerator.ProxyMethod)var15.next();</span><br><span class="line">                <span class="comment">//将代理类字段声明为Method，并且字段修饰符为private static，</span></span><br><span class="line">                <span class="keyword">this</span>.fields.add(<span class="keyword">new</span> ProxyGenerator.FieldInfo(var16.methodFiledName, <span class="string">"Ljava/lang/reflect/Method;"</span>, <span class="number">10</span>));</span><br><span class="line">                <span class="comment">//生成代理类的方法</span></span><br><span class="line">                <span class="keyword">this</span>.methods.add(var16.generateMethod());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//为代理类生成静态代码块对某些字段进行初始化</span></span><br><span class="line">        <span class="keyword">this</span>.methods.add(<span class="keyword">this</span>.generateStaticInitializer());</span><br><span class="line">    &#125;<span class="keyword">catch</span>()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里，有点头绪，其实JDK的动态代理是通过接口进行反射重新构造出一个实现类，然后每次调用的时候，将调用invoke方法进行方法的修改。</p>
<p>下次再深入理解下CGLIB</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2017/06/22/JDk动态代理与CGLIB动态代理的区别以及它们实现原理/" data-id="cjyms8juv000wdwudc81ylp9a" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-SpringMVC实现原理及详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2017/06/20/SpringMVC实现原理及详解/" class="article-date">
  <time datetime="2017-06-20T14:09:04.000Z" itemprop="datePublished">2017-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2017/06/20/SpringMVC实现原理及详解/">SpringMVC实现原理及详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="SpringMVC介绍"><a href="#SpringMVC介绍" class="headerlink" title="SpringMVC介绍"></a>SpringMVC介绍</h3><p>SpringMVC框架是以请求为驱动，围绕Servlet设计，将请求发给控制器，然后通过模型对象，分派器来展示请求结果视图。其中核心类是DispatcherServlet，它是一个Servlet，顶层是实现的Servlet接口。</p>
<h3 id="SpringMVC使用"><a href="#SpringMVC使用" class="headerlink" title="SpringMVC使用"></a>SpringMVC使用</h3><p>需要在web.xml中配置DispatcherServlet。并且需要配置spring监听器ContextLoaderListener<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring/<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2017/06/20/SpringMVC实现原理及详解/" data-id="cjyms8js5000cdwudswoi2mh4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-消息中间件之ActiveMQ-源码篇" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2017/06/20/消息中间件之ActiveMQ-源码篇/" class="article-date">
  <time datetime="2017-06-20T00:59:25.000Z" itemprop="datePublished">2017-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2017/06/20/消息中间件之ActiveMQ-源码篇/">消息中间件之ActiveMQ(源码篇（客户端）)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>ActiveMQ源码分为客户端和服务端，开始分析客户端代码：</p>
<h3 id="连接服务端"><a href="#连接服务端" class="headerlink" title="连接服务端"></a>连接服务端</h3><p>首先还是贴代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ActiveMQConnectionFactory factory = <span class="keyword">new</span> ActiveMQConnectionFactory(username, password, url);</span><br><span class="line">ActiveMQConnection connection = factory.createConnection();</span><br><span class="line">connection.start();</span><br></pre></td></tr></table></figure></p>
<p>和所有连接服务端差不多，<font color="red">首先通过factory构造方法，获取到连接端url、username、password，接下来创建connection对象，最后建立连接。</font></p>
<p>好了，从构造函数分析，比较简单：</p>
<h4 id="ActiveMQConnectionFactory的构造方法"><a href="#ActiveMQConnectionFactory的构造方法" class="headerlink" title="ActiveMQConnectionFactory的构造方法"></a>ActiveMQConnectionFactory的构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ActiveMQConnectionFactory</span><span class="params">(String username,String password,URI brokerURL)</span> </span>&#123;</span><br><span class="line">	setUserName(username);</span><br><span class="line">    setPassword(password);</span><br><span class="line">    setBrokerURL(brokerURL.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实也就是一些属性的填充，然后构造此工厂对象，此时必要的属性已经有了，接下来，也就是配置connection，也就是factory的createConnection()方法。</p>
<h4 id="ActiveMQConnectionFactory的createConnection-方法"><a href="#ActiveMQConnectionFactory的createConnection-方法" class="headerlink" title="ActiveMQConnectionFactory的createConnection()方法"></a>ActiveMQConnectionFactory的createConnection()方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立Transport和通过Transport建立Connection</span></span><br><span class="line">Transport transport = createTransport();</span><br><span class="line">connection = createActiveMQConnection(transport, factoryStates);</span><br><span class="line"><span class="comment">//配置</span></span><br><span class="line">connection.setUserName(userName);</span><br><span class="line">connection.setPassword(password);</span><br><span class="line">configureConnection(connection);</span><br><span class="line"><span class="comment">//启动Transport</span></span><br><span class="line">transport.start();</span><br></pre></td></tr></table></figure>
<font color="red">configureConnection(connection)</font>这个方法的作用是<font color="red">对实例化出的ActiveMQConnection对象中的参数的一系列配置。</font><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransportFactory</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> FactoryFinder TRANSPORT_FACTORY_FINDER = <span class="keyword">new</span> FactoryFinder(<span class="string">"META-INF/services/org/apache/activemq/transport"</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Transport <span class="title">connect</span><span class="params">(URI location)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	TransportFactory tf = findTransportFactory(location);</span><br><span class="line">        <span class="keyword">return</span> tf.doConnect(location);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TransportFactory <span class="title">findTransportfactory</span><span class="params">(URI location)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    	<span class="comment">//拆分url</span></span><br><span class="line">        String scheme = location.getScheme();</span><br><span class="line">        <span class="keyword">if</span>(scheme == <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">        &#125;</span><br><span class="line">        TransportFactory tf = TRANSPORT_FACTORYS.get(scheme);</span><br><span class="line">        <span class="keyword">if</span>(tf == <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="comment">//调用FactoryFinder找到正确的TransportFactory</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">            	tf = (TransportFactory)TRANSPORT_FACTORY_FINDER.newInstance(scheme);</span><br><span class="line">                TRANSPORT_FACTORYS.put(scheme, tf);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(Throwable e) &#123;</span><br><span class="line">            	<span class="keyword">throw</span> IOExceptionSupport.create();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryFinder</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过ObjectFactory来找到正确的TransportFactory</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(String key)</span> <span class="keyword">throws</span> IllegalAccessException... </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> objectFactory.create(path+key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>AMQ实现了工厂类Factoryfinder，在TransportFactory.connection(url)方法中，先是通过FactoryFinder根据url参数前缀“tcp:”来找到使用的协议工厂TcpTransportFactory，然后使用TcpTransportFactory中的类来进行连接的建立。<br>从代码上看，大致上可以得出这么个流程：<br>1. <font color="red">TransportFactory的connect()调用findTransportFactory方法</font><br>2. <font color="red">findTransportFactory调用FactoryFinder类的newInstance方法</font><br>3. <font color="red">newInstance调用ObjectFactory类的create方法</font><br>4. <font color="red">ObjectFactory是一个接口类，实现类是StandaloneObjectFactory，其中的create方法调用自身的loadClass方法</font><br>5. <font color="red">loadClass方法中最终找到正确的类，返回至TransportFactory中</font><br>6. <font color="red">如果是tcp连接，最终得到的就是一个实例化的TcpTransportFactory类</font>

<p>这边分析到了factory的查找和创建，下面开始分析创建Transport(其实由TransportFactory类的doCreate()方法创建)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Transport <span class="title">doConnect</span><span class="params">(URI location)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">    	<span class="comment">//把url里关于Transport的配置提取出来，WireFormat基本都可以看成是url的配置。如果使用Openwire，那么WireFormat就是openwire的相关配置。</span></span><br><span class="line">        Map&lt;String, String&gt; options = <span class="keyword">new</span> HashMap&lt;String, String&gt;(URISupport.parseParameters(location));</span><br><span class="line">        <span class="keyword">if</span>(!options.containsKey(<span class="string">"wireFormat.host"</span>))&#123;</span><br><span class="line">        	options.put(<span class="string">"wireFormat.host"</span>, location.getHost());</span><br><span class="line">        &#125;</span><br><span class="line">        WireFormat wf = createWireFormat(options);</span><br><span class="line">        <span class="comment">//建立socket连接</span></span><br><span class="line">        Transport transport = createTransport(location, wf);</span><br><span class="line">        <span class="comment">//装饰者模式</span></span><br><span class="line">        Transport rc = configure(transport, wf, options);</span><br><span class="line">        <span class="comment">//remove auto</span></span><br><span class="line">        IntrospectionSupport.extractProperties(options, <span class="string">"auto."</span>);</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> rc</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这方法其实就是对于Transport对象的封装并进行服务端的连接：</p>
<ol>
<li>配置wireformat</li>
<li>建立TcpTransport连接</li>
<li>在连接上包装辅助功能</li>
</ol>
<p>这边顺便提一下装饰器方法的四大辅助功能：</p>
<ol>
<li>MutexTransportFilter类实现了对每个请求的同步锁，同一时间只允许发送一个请求，如果有第二个请求需要等待第一个请求发送完毕才可以继续发送</li>
<li>WireFormatNegotiator类实现了在客户端连接broker的时候先发送数据解析相关的协议信息。</li>
<li>InactivityMonitor类实现了连接成功后启动心跳检查机制，客户端每10秒发送一次心跳信息，服务端每30秒读一次心跳信息，如果没有读到则会断开连接，心跳检测是互相的，客户端也会每30秒读取服务端发送来的心跳信息，如果没有读到也一样会断开连接。</li>
<li>ResponseCorrelator类实现了异步请求但需要获取响应信息否则就会阻塞等待功能。<h4 id="ActiveMQConnection的Start-方法"><a href="#ActiveMQConnection的Start-方法" class="headerlink" title="ActiveMQConnection的Start()方法"></a>ActiveMQConnection的Start()方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">	checkClosedOrFailed();</span><br><span class="line">    ensureConnectionInfoSent();</span><br><span class="line">    <span class="keyword">if</span>(started.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>))&#123;</span><br><span class="line">    	<span class="keyword">for</span>(Iterator&lt;ActiveMQSession&gt; i = sessions.iterator(); i.hasNext();) &#123;</span><br><span class="line">        	ActiveMQSession session = i.next();</span><br><span class="line">            session.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>start就是启动connection可以接收消息的功能。包含几个步骤：</p>
<ol>
<li>检查连接是否关闭或失效</li>
<li>确认客户端的ConnectionInfo是否被送到服务器</li>
<li>启动这个Connection中的每一个Session</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2017/06/20/消息中间件之ActiveMQ-源码篇/" data-id="cjyms8jtq000rdwudemd0n6bt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-消息中间件之ActiveMQ（原理篇）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2017/06/19/消息中间件之ActiveMQ（原理篇）/" class="article-date">
  <time datetime="2017-06-19T15:01:32.000Z" itemprop="datePublished">2017-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2017/06/19/消息中间件之ActiveMQ（原理篇）/">消息中间件之ActiveMQ（原理篇）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>首先先分析一下ActiveMQ的消息存储机制：</p>
<h3 id="KahaDB"><a href="#KahaDB" class="headerlink" title="KahaDB"></a>KahaDB</h3><p>目前ActiveMQ版本的默认存储方式。KahaDB存储是一个基于文件的快速存储消息，设计目标是使用容易并且尽可能快。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">broker</span> <span class="attr">brokerName</span>=<span class="string">"broker"</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">persistenceAdapter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">kahaDB</span> <span class="attr">directory</span>=<span class="string">"activemq-data"</span> <span class="attr">journalMaxFileLength</span>=<span class="string">"32mb"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">persistenceAdapter</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">broker</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>先看一下实际ActiveMQ的KahaDB存储方式下的数据目录如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ll -s -t -h</span><br><span class="line">total 11M</span><br><span class="line">232K -rw-rw-r-- 1 cdhfive cdhfive 228K Jun 18 09:27 db.data</span><br><span class="line">52K -rw-rw-r-- 1 cdhfive cdhfive 49K Jun 18 09:27 db.redo</span><br><span class="line">9.9M -rw-rw-r-- 1 cdhfive cdhfive 32M Jun 18 09:27 db-5.log</span><br><span class="line">4.0K -rw-rw-r-- 1 cdhfive cdhfive 8 Jun 14 10:37 lock</span><br></pre></td></tr></table></figure>
<p>解释一下四个文件：</p>
<ol>
<li>db.data</li>
</ol>
<p>它是消息的索引文件。本质上是B-Tree的实现，使用B-Tree作为索引指向db-*.log里面存储的消息。</p>
<ol start="2">
<li>db.redo</li>
</ol>
<p>主要用来进行消息恢复。</p>
<ol start="3">
<li>db-*.log</li>
</ol>
<p>存储消息的内容。对于一个消息而言，不仅仅有消息本身的数据（message data），而且还有（Destinations、订阅关系、事务…）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">the data logs contain all of the message data and all of the information about destinations,subscriptions,transactions,etc..</span><br></pre></td></tr></table></figure></p>
<p>data.log以日志形式存储消息，而且<font color="red">新的数据总是以APPEND的方式追加到日志文件末尾。</font>因此，消息的存储是很快的。比如，对于持久化消息，Producer把消息发送给Broker，Broker先把消息存储到磁盘中，然后再向Producer返回Acknowledge。Append方式在一定程度上减少了Broker向Producer返回Acknowledge的时间。</p>
<ol start="4">
<li>lock文件</li>
</ol>
<p>另外，一些关于KahaDB的配置选项如下：</p>
<ol>
<li><p>indexWriteBatchSize 默认值1000，当Metadata Cache中更新的索引到达了1000时，才同步到磁盘上的Metadata Store中。<font color="red">不是每次更新都写磁盘，而是批量更新写磁盘，比较写磁盘的代价是很大的。</font></p>
</li>
<li><p>indexCacheSize 默认值10000，(number of index pages cached in memory)，在内存中最多分配个页面来缓存index。缓存的index越多，命中的概率就越大，检索的效率就越高。</p>
</li>
<li><p>journalMaxFileLength 默认值32MB，当存储的消息达到32MB时，新建一个新文件来保存消息。这个配置对生产者或消息者的速率有影响。比如，生产者速率很快而消费者速率很慢时，将它配置得大一点比较好。</p>
</li>
<li><p>enableJournalDiskSyncs 默认值true，默认采用同步写磁盘，即消息先存储到磁盘中再向Producer返回ACK。</p>
</li>
<li><p>cleanupinterval 默认值30000ms，当消息被消息者成功消费之后，Broker就可以将消息删除了。</p>
</li>
<li><p>checkpointInterval 默认值5s，每隔5s将内存中index(Metadata Cache)更新到磁盘的Index文件中（Metadata Store）。</p>
</li>
</ol>
<h4 id="kahaDB存储底层实现"><a href="#kahaDB存储底层实现" class="headerlink" title="kahaDB存储底层实现"></a>kahaDB存储底层实现</h4><p>各个部分与KahaDB配置的存储目录下的文件是一一对应的。</p>
<ol>
<li>在内存（cache）中的那部分B-Tree是Metadata Cache</li>
</ol>
<p>通过将索引缓存到内存中，可以加快查询的速度。但是需要定时将Metadata Cache与Metadata Store同步。</p>
<p><font color="red">同步过程称为：check point。</font>由上面介绍参数checkpointInterval选项决定每隔多久时间进行一次checkpoint操作。</p>
<ol start="2">
<li>BTree Indexs则是保存在磁盘上的，称为Metadata Store，它对应于文件db.data，它就是对Data Logs以B树的形式索引。有了它，Broker（消息服务器）可以快速地重启恢复，因为它是消息的索引，根据它就能恢复每条消息的location。</li>
</ol>
<p>如果Metadata Store被损坏，则只能扫描整个Data Logs来重建B树了，这个过程十分缓慢。</p>
<ol start="3">
<li>Data Logs则对应于文件db-*.log,默认是32MB</li>
</ol>
<p>Data Logs以日志形式存储消息，它是生产者生产的数据的真正载体。</p>
<ol start="4">
<li>Redo Log则对应于文件db.redo</li>
</ol>
<p>redo log的原理用到了“Double write”。</p>
<p>下面贴一点代码，关于“Double write”：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> unload <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="comment">//load时创建writeFile（db.data）和recoveryFile(db.redo)</span></span><br><span class="line">    writeFile = <span class="keyword">new</span> RecoverableRandomAccessFile(file, <span class="string">"rw"</span>, <span class="keyword">false</span>);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(enableRecoveryFile) &#123;</span><br><span class="line">    	recoveryFile = <span class="keyword">new</span> RecoverableRandomAccessFile(getRecoveryFile(), <span class="string">"rw"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeBatch</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//数据写入磁盘时，先写到Recovery Buffer中</span></span><br><span class="line">    <span class="keyword">for</span>(PageWrite w: batch) &#123;</span><br><span class="line">    	<span class="keyword">try</span>&#123;</span><br><span class="line">        	checksum.update(w.getDiskBound(), <span class="number">0</span>, pageSize);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">        	<span class="keyword">throw</span> IOExceptionSupport.create();</span><br><span class="line">        &#125;</span><br><span class="line">        recoveryFile.writeLong(w.page.getPageId());</span><br><span class="line">        recoveryFile.write(w.getDiskBound(), <span class="number">0</span>, pageSize);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写入真正的目的文件中</span></span><br><span class="line">    <span class="keyword">for</span>(PageWrite w: batch) &#123;</span><br><span class="line">    	writeFile.seek(toOffset(w.page.getPageId()));</span><br><span class="line">        writeFile.write(w.getDiskBound(),<span class="number">0</span>,pageSize);</span><br><span class="line">        w.done();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="AMQ"><a href="#AMQ" class="headerlink" title="AMQ"></a>AMQ</h3><p>AMQ消息存储是可靠持久性和高性能索引的事务日志组合，当消息吞吐量是应用程序的主要需求时，该存储是最佳选择。但因为它为每个索引使用两个分开的文件，并且每隔Destination都有一个索引。</p>
<p>与KahaDB类似，主要包括以下几部分：</p>
<ol>
<li>Data Logs：作为消息Journal。</li>
<li>Cache：在消息写入data log后，在内存中保持消息用于快速恢复。</li>
<li>Reference Store：在journal保存消息的引用，按照消息ID索引。<h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3></li>
</ol>
<p>选择关系型数据库，通常原因是企业已经具备管理关系型数据的专长，但它的性能上不优于上述消息存储实现。</p>
<h3 id="内存存储"><a href="#内存存储" class="headerlink" title="内存存储"></a>内存存储</h3><p>内存消息存储器将所有持久化消息保存于内存中。在少量数量Message的情况下，内存消息存储会很有用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2017/06/19/消息中间件之ActiveMQ（原理篇）/" data-id="cjyms8jts000sdwudpsthnyvu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/lfhboke.github.io/page/2/">&laquo; Prev</a><a class="page-number" href="/lfhboke.github.io/">1</a><a class="page-number" href="/lfhboke.github.io/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/lfhboke.github.io/page/4/">4</a><a class="page-number" href="/lfhboke.github.io/page/5/">5</a><a class="extend next" rel="next" href="/lfhboke.github.io/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2016/01/">January 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/lfhboke.github.io/2019/07/27/netty入门应用/">netty入门应用</a>
          </li>
        
          <li>
            <a href="/lfhboke.github.io/2019/07/21/netty开篇/">netty开篇</a>
          </li>
        
          <li>
            <a href="/lfhboke.github.io/2019/07/14/web-xml配置文件详解/">web.xml配置文件详解</a>
          </li>
        
          <li>
            <a href="/lfhboke.github.io/2019/07/14/spring过滤器/">spring过滤器</a>
          </li>
        
          <li>
            <a href="/lfhboke.github.io/2019/07/14/spring拦截器HandlerInterceptor/">spring拦截器HandlerInterceptor</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 lfhu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/lfhboke.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="/lfhboke.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/lfhboke.github.io/fancybox/jquery.fancybox.css">
  <script src="/lfhboke.github.io/fancybox/jquery.fancybox.pack.js"></script>


<script src="/lfhboke.github.io/js/script.js"></script>



  </div>
</body>
</html>