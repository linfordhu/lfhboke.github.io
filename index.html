<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>lfh&#39;s bokes</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="lfh&#39;s bokes">
<meta property="og:url" content="https://linfordhu.github.io/lfhboke.github.io/index.html">
<meta property="og:site_name" content="lfh&#39;s bokes">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lfh&#39;s bokes">
  
    <link rel="alternate" href="/lfhboke.github.io/atom.xml" title="lfh&#39;s bokes" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/lfhboke.github.io/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/lfhboke.github.io/" id="logo">lfh&#39;s bokes</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/lfhboke.github.io/">Home</a>
        
          <a class="main-nav-link" href="/lfhboke.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/lfhboke.github.io/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://linfordhu.github.io/lfhboke.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-netty入门应用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2019/07/27/netty入门应用/" class="article-date">
  <time datetime="2019-07-27T11:40:15.000Z" itemprop="datePublished">2019-07-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2019/07/27/netty入门应用/">netty入门应用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="Netty服务端开发"><a href="#Netty服务端开发" class="headerlink" title="Netty服务端开发"></a>Netty服务端开发</h4><p>作为第一个Netty的应用例程哪个，为了能够将精力集中在Netty的使用上，以时间服务器为例进行源码开发和代码讲解。</p>
<p>使用NIO进行服务端开发的步骤。</p>
<ol>
<li>创建ServerSocketChannel，配置它为非阻塞模式；</li>
<li>绑定监听，配置TCP参数，例如backlog大小；</li>
<li>创建一个独立的IO线程，用于轮询多路复用器Selector；</li>
<li>创建Selector，将之前创建的ServrSocketChannl注册到Selector上，监听SelectionKey.ACCEPT；</li>
<li>启动IO线程，在循环体中执行Selector.select()方法，轮询就绪的Channel；</li>
<li>当轮询到了处于就绪状态的Channel时，需要对其进行判断，如果是OP_ACCEPT状态，说明是新的客户端接入，则调用ServerSocketChannel.accept()方法接受新的客户端；</li>
<li>设置新接入的客户端链路SocketChannel为非阻塞模式，配置其他的一些TCP参数；</li>
<li>将SocketChannel注册到Selector，监听OP_READ操作位；</li>
<li>如果轮询的Channel为OP_READ，则说明SocketChannel中有新的就绪的数据包需要读取，则构造ByteBuffer对象，读取数据包；</li>
<li>如果轮询的Channel为OP_WRITE，说明还有数据没有发送完成，需要继续发送。</li>
</ol>
<p>现在，看看Netty如何开发服务端。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeServer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">        	ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">            	.channl(NioServerSocketChannel.class)</span><br><span class="line">                .option(ChannelOption.SO_BACKLOG,<span class="number">1024</span>)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChildChannelHandler());</span><br><span class="line">            ChannelFuture f = b.bind(port).sync();</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        	bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildChannelHandler</span> <span class="keyword">extends</span> <span class="title">ChannelIntializer</span>&lt;<span class="title">SocketChannl</span>&gt; </span>&#123;</span><br><span class="line">    	<span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel arg0)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        	arg0.pipeline().addLast(<span class="keyword">new</span> TimeServerHandler());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> port = <span class="number">8080</span>;</span><br><span class="line">        <span class="keyword">if</span>(args != <span class="keyword">null</span> &amp;&amp; args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="keyword">try</span> &#123;</span><br><span class="line">            	port = Integer.valueOf(args[<span class="number">0</span>]);</span><br><span class="line">            &#125;<span class="keyword">catch</span>()&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> TimeServer().bind(port);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从bind方法开始学习，在代码20~21行创建了两个NioEventLoopGroup实例。NioEvent LoopGroup是个线程组，它包含了一组NIO线程，专门用于网络事件的处理，实际上它们就是Reactor线程组。这里创建两个的原因是一个用于服务端接收客户端的连接，另一个用于进行SocketChannel的网络读写。第23行创建ServerBootstrap对象，它是Netty用于启动NIO服务端的辅助启动类，目的是降低服务端的开发复杂度。第24行调用ServerBootstrap的group方法，将两个NIO线程组当作入参传递到ServerBootstrap中。接着设置创建的Channel为NioServerSocketChannel，它的功能对应于JDK NIO类库中的ServerSocketChannel类。然后配置NioServerSocketChannel的TCP参数，此处将它的backlog设置为1024，最后绑定IO事件的处理类ChildChannelHandler，它的作用类似于Reactor模式中的Handler类，主要用于处理网络IO事件，例如记录日志、对消息进行编解码等。</p>
<p>服务端启动辅助类配置完成之后，调用它的bind方法绑定监听端口，随后，调用它的同步阻塞方法sync等待绑定操作完成。完成之后Netty会返回一个ChannelFuture，它的功能类似于JDK的java.util.concurrent.Future，主要用于异步操作的通知回调。</p>
<p>第32行使用f.channel().closFutur().sync()方法进行阻塞，等待服务端链路关闭之后main函数才退出。</p>
<p>第34~36行调用NIO线程组的shutdownGracefully进行优雅退出，它会释放跟shutdownGracefully相关联的资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channlRead</span><span class="params">(ChannelHandlerContext ctx, Objct msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        <span class="keyword">byte</span>[] req = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.readableBytes()];</span><br><span class="line">        buf.readBytes(req);</span><br><span class="line">        String body = <span class="keyword">new</span> String(req, <span class="string">"UTF-8"</span>);</span><br><span class="line">        System.out.println(<span class="string">"The time server receive order:"</span> + body);</span><br><span class="line">        String currentTime = <span class="string">"QUERY TIME ORDER"</span>.equalsIgnoreCase(body)?<span class="keyword">new</span> java.util.Date(System.currentTimeMillis()).toString():<span class="string">"BAD ORDER"</span>;</span><br><span class="line">        ByteBuf resp = Unpooled.copiedBuffer(currentTime.getBytes());</span><br><span class="line">        ctx.write(resp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable <span class="keyword">case</span>)</span> </span>&#123;</span><br><span class="line">    	ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TimeServerHandler继承自ChannelHandlerAdapter，它用于对网络事件进行读写操作，通常只需要关注channelRead和excptionCaught方法。下面对这两个方法进行简单说明。</p>
<p>第17行做类型转换，将msg转换成Netty的ByteBuf对象。ByteBuf类似于JDK中的java.nio.ByteBuffer对象，不过它提供了更加强大和灵活的功能。通过ByteBuf的readableBytes方法可以获取缓冲区可读的字节数，根据可读的字节数创建byte数组，通过ByteBuf的readBytes方法将缓冲区中的字节数组复制到新建的byte数组中，最后通过new String构造函数获取请求消息。这时对请求消息进行判断，如果是”QUERY TIME ORDER”则创建应答消息，通过ChannelHandlerContext的write方法异步发送应答消息给客户端。</p>
<p>第30行调用了ChannelHandlerContext的flush方法，它的作用是将消息发送队列中的消息写入到SocketChannel中发送给对方。从性能角度考虑，为了防止频繁地唤醒selector进行消息发送，Netty的write方法并不直接将消息写入SocketChannel中，调用write方法只是把待发送的消息放到发送缓冲数组中，再通过调用flush方法，将发送缓冲区中的消息全部写到SocketChannel中。</p>
<h4 id="Netty客户端开发"><a href="#Netty客户端开发" class="headerlink" title="Netty客户端开发"></a>Netty客户端开发</h4><p>Netty客户端开发相比服务端更简单。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimClient</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> port, String host)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            b.group(group).channel(NioSocketChannel.class)</span><br><span class="line">            	.option(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;()&#123;</span><br><span class="line">                	<span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> throw Exception </span>&#123;</span><br><span class="line">                    	ch.pipeline().addLast(<span class="keyword">new</span> TimeClientHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            ChannelFuture f = b.connect(host, port).sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        	group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> port = <span class="number">8080</span>;</span><br><span class="line">        <span class="keyword">if</span>(args != <span class="keyword">null</span> &amp;&amp; args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="keyword">try</span> &#123;</span><br><span class="line">            	port = Integer.valueOf(args[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">catch</span>()&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> TimeClient().connect(port, <span class="string">"127.0.0.1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从connect，在第20行首先创建客户端IO读写的NioEventLoopGroup线程组，然后继续创建客户端辅助启动类Bootstrap，随后需要对其进行配置。与服务端不同的是，它的Channel需要设置为NioSocketChannel，然后为其添加Handler。此处为了简单直接创建匿名内部类，实现initChannel方法，其作用是当创建NioSocktChannel成功之后，在进行初始化时，将它的ChannelHandler设置到ChannelPipeline中，用于处理网络IO事件。</p>
<p>客户端启动辅助类设置完成之后，调用connect方法发起异步连接，然后调用同步方法等待连接成功。</p>
<p>最后，当客户端连接关闭之后，客户端主函数退出，退出之前释放NIO线程组的资源。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannlHandlrAdapter</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ByteBuf firstMessage;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimeClientHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">byte</span>[] req = <span class="string">"QUERY TIME ORDER"</span>.getBytes();</span><br><span class="line">        firstMessag = Unpooled.buffer(req.length);</span><br><span class="line">        firstMessage.writeBytes(req);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    	ctx.writeAndFlush(firstMessage);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channlRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">    	ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        <span class="keyword">byte</span>[] req = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.readableBytes()];</span><br><span class="line">        buf.readBytes(req);</span><br><span class="line">        String body = <span class="keyword">new</span> String(req. <span class="string">"UTF-8"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Now is:"</span>+body);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">    	ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里关注：channelActive、channelRead和exceptionCaught。当客户端和服务端TCP链路建立成功之后，Netty的NIO线程会调用channelActive方法，发送查询时间的指令给服务端，调用ChannelHandlerContext的writeAndFlush方法将请求消息发送给服务端。</p>
<p>当服务端返回应答消息时，channelRead方法被调用，第39~43行从Netty的ByteBuf中读取并打印应答消息。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2019/07/27/netty入门应用/" data-id="cjyms8jv8000zdwudsyddwk4g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-netty开篇" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2019/07/21/netty开篇/" class="article-date">
  <time datetime="2019-07-21T03:41:47.000Z" itemprop="datePublished">2019-07-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2019/07/21/netty开篇/">netty开篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="IO编程"><a href="#IO编程" class="headerlink" title="IO编程"></a>IO编程</h4><p>举一个场景的例子：客户端每隔两秒发送一个带有时间戳的”hello world”给服务端，服务端收到之后打印。<br>现在通过几种不同的IO方式编程实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IOServer.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOServer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        	<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            	Socket socket = serverSocket.accept();</span><br><span class="line">                <span class="keyword">new</span> Thread() -&gt; &#123;</span><br><span class="line">                	<span class="keyword">try</span> &#123;</span><br><span class="line">                    	<span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                        InputStream inputStream = socket.getInputStream();</span><br><span class="line">                        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                        	<span class="keyword">int</span> len;</span><br><span class="line">                            <span class="keyword">while</span>((len = inputStream.read(data)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                            	System.out.println(<span class="keyword">new</span> String(data, <span class="number">0</span>, len));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span>(Exception e) &#123;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>server端首先创建了一个serverSocket来监听8000端口，然后创建一个线程，线程里面不断调用阻塞方法serversocket.accept();获取新的连接，见(1)，当获取到新的连接之后，给每条连接创建一个新的线程，这个线程负责从该连接中读取数据，然后读取数据是以字节流的方式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOClient</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        	<span class="keyword">try</span>&#123;</span><br><span class="line">            	Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">8000</span>);</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                	<span class="keyword">try</span>&#123;</span><br><span class="line">                    	socket.getOutputStream().write((<span class="keyword">new</span> Date() + <span class="string">":hello world"</span>).getBytes());</span><br><span class="line">                        socket.getOutputStream().flush();</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>IO编程模型在客户端较少的情况下运行良好，但是对于客户端比较多的业务来说，单机服务端可能需要支撑成千上万的连接，IO模型可能就不太合适了。</p>
<p>上面的demo，从服务端代码中我们可以看到，在传统的IO模型中，每个连接创建成功之后都需要一个线程来维护，每个线程包含一个while死循环，那么1w个连接对应1w个线程，继而1w个while死循环，这就带来了如下问题：</p>
<ol>
<li>线程资源受限：线程是操作系统中非常宝贵的资源，同一时刻有大量的线程处于阻塞状态是非常严重的资源浪费，操作系统耗不起。</li>
<li>线程切换效率低下：单机cpu核数固定，线程爆炸之后操作系统频繁进行线程切换，应用性能急剧下降。</li>
<li>除了以上两个问题，IO编程中，我们看到数据读写是以字节流为单位，效率不高。<h4 id="NIO编程"><a href="#NIO编程" class="headerlink" title="NIO编程"></a>NIO编程</h4>关于NIO相关的文章网上也有很多，这里不打算详细深入分析，下面简单描述一下NIO是如何解决以上三个问题的。<h5 id="线程资源受限"><a href="#线程资源受限" class="headerlink" title="线程资源受限"></a>线程资源受限</h5>NIO编程模型中，新来一个连接不再创建一个新的线程，而是可以把这条连接直接绑定到某个固定的线程，然后这条连接所有的读写都由这个线程来负责，那么他是怎么做到？<br><img src="/lfhboke.github.io/css/images/netty.PNG" alt="netty"><br>如上图，IO模型中，一个连接来了，会创建一个线程，对应一个while死循环，死循环的目的就是不断监测这条连接上是否有数据可以读，大多数情况下，1w个连接里面同一时刻只有少量的连接有数据可读，因此，很多个while死循环都浪费掉了，因为读不出啥数据。</li>
</ol>
<p>而NIO模型中，他把这么多while死循环变成一个死循环，这个死循环由一个线程控制，那么他又是如何做到一个线程，一个while死循环就能监测1w个连接是否有数据可读的呢？</p>
<p>这就是NIO模型中selector的作用，一条连接来了之后，现在不创建一个while死循环去监听是否有数据可读了，而是直接把这条连接注册到selector上，然后，通过检查这个selector，就可以批量监测出有数据可读的连接，进而读取数据，下面我再举个非常简单的生活中的例子说明IO与NIO的区别。</p>
<h5 id="线程切换效率低下"><a href="#线程切换效率低下" class="headerlink" title="线程切换效率低下"></a>线程切换效率低下</h5><p>由于NIO模型中线程数量大大降低，线程切换效率因此也大幅度提高</p>
<h5 id="IO读写以字节为单位"><a href="#IO读写以字节为单位" class="headerlink" title="IO读写以字节为单位"></a>IO读写以字节为单位</h5><p>NIO解决这个问题的方式是数据读写不再以字节为单位，而是以字节块为单位。而是以字节块为单位。IO模型中，每次都是从操作系统底层一个字节一个字节地读取数据，而NIO维护一个缓冲区，每次可以从这个缓冲区里面读取一块的数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NIOServer.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    	Selector serverSelector = Selector.open();</span><br><span class="line">        Selector clientSelector = Selector.open();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        	<span class="keyword">try</span>&#123;</span><br><span class="line">            	ServerSocketChannel listenerChannel = ServerSocketChannel.open();</span><br><span class="line">                listenerChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8000</span>));</span><br><span class="line">                listenerChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                listenerChannel.register(serverSelector, SelectionKey.OP_ACCEPT);</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                	<span class="keyword">if</span>(serverSelector.select(<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    	Set&lt;SelectionKey&gt; set = serverSelector.selectedKeys();</span><br><span class="line">                        Iterator&lt;SelectionKey&gt; keyIterator = set.iterator();</span><br><span class="line">                        <span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">                        	SelectionKey key = keyIterator.next();</span><br><span class="line">                            <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">                            	<span class="keyword">try</span>&#123;</span><br><span class="line">                                	SocketChannel clientChannel = ((ServerSocketChannel) key.channel()).accept();</span><br><span class="line">                                    clientChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                                    clientChannel.register(clientSelector, SelectionKey.OP_READ);</span><br><span class="line">                                &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                                	keyIterator.remove();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        	<span class="keyword">try</span>&#123;</span><br><span class="line">            	<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                	<span class="keyword">if</span>(clientSelector.select(<span class="number">1</span>)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    	Set&lt;SelectionKey&gt; set = clientSelector.selectedKeys();</span><br><span class="line">                        Iterator&lt;SelectionKey&gt; keyIterator = set.iterator();</span><br><span class="line">                        <span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">                        	SelectionKey key = keyIterator.next();</span><br><span class="line">                            <span class="keyword">if</span>(key.isReadable()) &#123;</span><br><span class="line">                            	<span class="keyword">try</span>&#123;</span><br><span class="line">                                	SocketChannel clientChannel = (SocketChannel) key.channel();</span><br><span class="line">                                    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                                    clientChannel.read(byteBuffer);</span><br><span class="line">                                    byteBuffer.flip();</span><br><span class="line">                                    System.out.println(Charset.defaultCharset().newDecoder().decode(byteBuffer).toString());</span><br><span class="line">                                &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                                	keyIterator.remove();</span><br><span class="line">                                    key.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>()&#123;&#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>解释一下核心思路：</p>
<ol>
<li>NIO模型中通常会有两个线程，每个线程绑定一个轮询器selector，在我们的例子中serverSelector负责轮询是否有新的连接，clientSelector负责轮询连接是否有数据可读。</li>
<li>服务端监测到新的连接之后，不再创建一个新的线程，而是直接将新连接绑定到clientSelector上，这样就不用IO模型中1w个while循环在死等。</li>
<li>clientSelector被一个while死循环包裹着，如果在某一时刻有多条连接有数据可读，那么通过clientSelector.select(1)方法可以轮询出来，进而批量处理。</li>
<li>数据的读写以内存块为单位。<h4 id="Netty编程"><a href="#Netty编程" class="headerlink" title="Netty编程"></a>Netty编程</h4>Netty封装了JDK的NIO，更简便。<br>Netty是一个异步事件驱动的网络应用框架，用于快速开发可维护的高性能服务和客户端。</li>
</ol>
<p>使用Netty不使用JDK原生NIO的原因：</p>
<ol>
<li>使用JDK自带的NIO需要了解太多的概念，编程复杂，一不小心bug横飞。</li>
<li>Netty底层IO模型随意切换，而这一切只需要做微小的改动，改改参数，Netty可以直接从NIO模型变身为IO模型。</li>
<li>Netty自带的拆包解包，异常监测等机制让你从NIO的繁重细节中脱离出来，让你只需要关心业务逻辑。</li>
<li>Netty解决了JDK的很多包括空轮询在内的bug</li>
<li>Netty底层对线程，selector做了很多细小的优化，精心设计的reactor线程模型做到非常高效的并发处理</li>
<li>自带各种协议栈让你处理任何一种通用协议都几乎不用亲自动手</li>
<li>Netty社区活跃，遇到问题随时邮件列表或者issue</li>
<li>Netty已经历各大rpc框架，消息中间件，分布式通信中间件线上的广泛验证，健壮性无比强大</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.1.6.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NettyServer.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        NioEventLoopGroup boss = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        serverBootstrap</span><br><span class="line">        	.group(boss, worker)</span><br><span class="line">            .channel(NioServerSocketChannel.class)</span><br><span class="line">            .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;()&#123;</span><br><span class="line">            	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">                	ch.pipeline().addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> SimpleChannelInboundHandler&lt;String&gt;()&#123;</span><br><span class="line">                    	<span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> </span>&#123;</span><br><span class="line">                        	System.out.println(msg);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .bind(<span class="number">8000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>boss对应，IOServer.java中的接受新连接线程，主要负责创建新连接</li>
<li>worker对应IOClient.java中的负责读取数据的线程，主要用于读取数据以及业务逻辑处理</li>
</ol>
<p>下面是客户端NIO的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    	Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        </span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">        	.channel(NioSocketChannel.class)</span><br><span class="line">            .handler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;()&#123;</span><br><span class="line">            	<span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> </span>&#123;</span><br><span class="line">                	ch.pipeline().addLaset(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            Channel channel = bootstrap.connect(<span class="number">127.0</span>.0.1<span class="string">", 8000).channel();</span></span><br><span class="line"><span class="string">            while (true) &#123;</span></span><br><span class="line"><span class="string">            	channel.writeAndFlush(new Date() + "</span>:hello world!<span class="string">");</span></span><br><span class="line"><span class="string">                Thread.sleep(2000);</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>在客户端程序中，group对应了我们IOClient.java中main函数起的线程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2019/07/21/netty开篇/" data-id="cjyms8jvc0010dwudr9vewus8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-web-xml配置文件详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2019/07/14/web-xml配置文件详解/" class="article-date">
  <time datetime="2019-07-14T07:36:59.000Z" itemprop="datePublished">2019-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2019/07/14/web-xml配置文件详解/">web.xml配置文件详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="一、web-xml是什么？"><a href="#一、web-xml是什么？" class="headerlink" title="一、web.xml是什么？"></a>一、web.xml是什么？</h4><p>首先web.xml是java web项目的一个重要的配置文件，但是web.xml文件并不是Java Web工程必须的。</p>
<p>web.xml文件是用来配置：欢迎页、servlet、filer等的。当你的web工程没用到这些时，可以不需要使用web.xml文件来配置你的web工程。</p>
<h5 id="web-xml能做的事情："><a href="#web-xml能做的事情：" class="headerlink" title="web.xml能做的事情："></a>web.xml能做的事情：</h5><p>其实，web.xml的模式（Schema）文件中定义了多少种标签元素，web.xml中就可以出现它的模式文件所定义的标签元素，它就能拥有定义出来的那些功能。</p>
<p>web.xml的模式文件是由Sun公司定义的，每个web.xml文件的根元素<web-app>中，都必须标明这个web.xml使用的是哪个模式文件。如：</web-app></p>
<h4 id="二、web-xml详解："><a href="#二、web-xml详解：" class="headerlink" title="二、web.xml详解："></a>二、web.xml详解：</h4><h5 id="1-web-xml加载过程"><a href="#1-web-xml加载过程" class="headerlink" title="1.web.xml加载过程"></a>1.web.xml加载过程</h5><p>首先简单讲一下，web.xml的加载过程。当启动一个WEB项目时，首先会读取项目web.xml<br>配置文件里的配置，当这一步没有出错并且完成之后，项目才能正常的被启动起来。</p>
<ol>
<li>启动WEB项目的时候，容器首先会去它的配置文件web.xml读取两个节点：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">2. 紧接着，容器创建一个ServletContext(application)，这个WEB项目所有部分都将共享这个上下文。</span><br><span class="line">3. 容器以```&lt;context-param&gt;&lt;/context-param&gt;```的name作为键，value作为值，将其转化为键值对，存入ServletContext。</span><br><span class="line">4. 容器创建```&lt;listener&gt;&lt;/listener&gt;```中的类实例，根据配置的class类路径```&lt;listener-class&gt;```来创建监听，在监听中会有contextInitialized(ServletContextEvent args)初始方法，启动Web应用时，系统调用Listener的该方法，在这个方法照中获得。</span><br><span class="line">5. 举例：你可能在项目启动之前就打开数据库，那么这里就可以在```&lt;context-param&gt;```中设置数据库的连接方式（驱动、url、user、password），在监听类中初始化数据库的连接。这个监听是自己写的一个类，除了初始化方法，它还有销毁方法，用于关闭应用前释放资源。比如：说数据库连接的关闭，此时，调用contextDestroyed(ServletContextEvent args)，关闭Web应用时，系统调用Listener的该方法。</span><br><span class="line">6. 接着，容器会读取```&lt;filter&gt;&lt;/filter&gt;```，根据指定的类路径来实例化过滤器。</span><br><span class="line">7. 以上都是在WEB项目还没有完全启动起来的时候就已经完成了的工作。如果系统中有Servlet，则Servlet是在第一次发起请求的时候被实例化的，而且一般不会被容器销毁，它可以服务于多个用户的请求。所以，Servlet的初始化都要比上面提到的那几个要迟。</span><br><span class="line">8. 总的来说，web.xml的加载顺序是：```&lt;context-param&gt;-&gt;&lt;listener&gt;-&gt;&lt;filer&gt;-&gt;&lt;servlet&gt;```。其中，如果web.xml中出现了相同的元素，则按照在配置文件中出现的先后顺序来加载。</span><br><span class="line">9. 对于某类元素而言，与它们出现的顺序是有关的。以```&lt;filter&gt;```为例，web.xml中当然可以定义多个filter，与filter相关的一个元素是```&lt;filter-mapping&gt;```，注意，对于拥有相同```&lt;filter-name&gt;```的filter和filter-mapping元素而言，filter-mapping必须出现在filter之后，否则当解析到filter-mapping时，它所对应的filter-name还未定义。web容器启动初始化每个filter时，按照filter出现的顺序来初始化的，当请求资源匹配多个filter-mapping时，filter拦截资源是按照filter-mapping元素出现的顺序来依次调用doFilter()方法的。servlet同filter类似。</span><br><span class="line">##### 2.web.xml标签详解</span><br><span class="line">###### 1.xml文档有效性检查</span><br><span class="line">1. web-app定义该文档（部署描述符，不是DTD文件）的根元素</span><br><span class="line">2. PUBLIC意味着DTD文件可以被公开使用</span><br><span class="line">3. -//Sun Microsysterms，Inc.//DTD Web Application 2.3//EN“意味着DTD由SunMicrosystems，Inc维护。”</span><br><span class="line">4. URL&quot;http://java.sun.com/dtd/web-app 2 3.dtd&quot;表示D文件的位置。</span><br><span class="line">##### 2.```&lt;web-app&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>部署描述符的根元素。</p>
<p>这个元素含有23个子元素，而且子元素都是可选的。问号（？）表示子元素是可选的，而且只能出现一次。星号（<code>*</code>）表示子元素可在部署描述符中出现零次或多次。有些子元素还可以有自己的子元素。web.xml文件中web-app元素声明的是下面每个子元素的声明。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2019/07/14/web-xml配置文件详解/" data-id="cjyms8jtj000odwudfsymug9i" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-spring过滤器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2019/07/14/spring过滤器/" class="article-date">
  <time datetime="2019-07-14T03:32:08.000Z" itemprop="datePublished">2019-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2019/07/14/spring过滤器/">spring过滤器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <font color="red">过滤器是什么？</font><br><font color="red">过滤器是如何实现的？</font><br><font color="red">过滤器和拦截器的区别？</font><br><font color="red">过滤器的核心原理是什么（阅读源码）？</font>

<h4 id="过滤器是什么？"><a href="#过滤器是什么？" class="headerlink" title="过滤器是什么？"></a>过滤器是什么？</h4><p>依赖于servlet容器。在实现上基于函数回调，可以对几乎所有请求进行过滤，但是缺点是一个过滤器实例只能在容器初始化时调用一次。使用过滤器的目的是用来做一些过滤操作。</p>
<p>对所有请求进行过滤操作，获取请求携带的数据或者修改请求的某些参数。</p>
<h4 id="过滤器的实现"><a href="#过滤器的实现" class="headerlink" title="过滤器的实现"></a>过滤器的实现</h4><h5 id="Spring自带的字符编码过滤器"><a href="#Spring自带的字符编码过滤器" class="headerlink" title="Spring自带的字符编码过滤器"></a>Spring自带的字符编码过滤器</h5><p>过滤器常用的场景：解决中文乱码问题。</p>
<p>字符编码过滤器主要是过滤response响应。</p>
<p>添加字符编码过滤器<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//web.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>字符集过滤器<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<pre><code>forceEncoding是强制字符集
true处理请求和响应，相当于：
request.setCharacterEncoding(&quot;&quot;);
response.setCharacterEncoding(&quot;&quot;);
false只处理请求，相当于
request.setCharacterEncoding(&quot;&quot;);
</code></pre><h5 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h5><p>写一个uri过滤器。</p>
<p>主要还是对过滤器进行说明，cookie自动登陆只是写了点皮毛。</p>
<p>uri过滤器主要实现的功能是：除了/login的uri，都要进行过滤处理，获取session值，看session里是否有用户信息，没有用户信息，就跳到登陆页面。</p>
<h6 id="写个过滤器的类SessionFilter-class"><a href="#写个过滤器的类SessionFilter-class" class="headerlink" title="写个过滤器的类SessionFilter.class"></a>写个过滤器的类SessionFilter.class</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException,IOException </span>&#123;</span><br><span class="line">    	String[] notFilter = <span class="keyword">new</span> String[]&#123;<span class="string">"/login"</span>&#125;;</span><br><span class="line">        String uri = request.getRequestURI();</span><br><span class="line">        System.out.println(<span class="string">"filter&gt;&gt;&gt;uri&gt;&gt;&gt;"</span>+uri);</span><br><span class="line">        <span class="keyword">boolean</span> doFilter = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(String s: notFilter) &#123;</span><br><span class="line">        	<span class="keyword">if</span>(uri.indexOf(s)!=-<span class="number">1</span>)&#123;</span><br><span class="line">            	doFilter = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(doFilter) &#123;</span><br><span class="line">        	System.out.println(<span class="string">"doFilter&gt;&gt;&gt;"</span>);</span><br><span class="line">            Object obj = request.getSession().getAttribute(<span class="string">"user"</span>);</span><br><span class="line">            <span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;</span><br><span class="line">            	System.out.println(<span class="string">"doFilter&gt;&gt;&gt;obj is null"</span>);</span><br><span class="line">                <span class="keyword">boolean</span> isAjaxRequest = isAjaxRequest(request);</span><br><span class="line">                <span class="keyword">if</span>(isAjaxRequest)&#123;</span><br><span class="line">                	response.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">                    response.sendError(HttpStatus.UNAUTHORIZED.value(),<span class="string">"您已经太长时间没有操作，请刷新页面"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"doFilter&gt;&gt;&gt;ajax request"</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                	System.out.println(<span class="string">"doFilter&gt;&gt;&gt;httpRequest"</span>);</span><br><span class="line">                    response.sendRedirect(<span class="string">"./login"</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            	User user = (User) obj;</span><br><span class="line">                System.out.println(<span class="string">"doFilter&gt;&gt;&gt;username&gt;&gt;&gt;"</span>+user.getUsername());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	System.out.println(<span class="string">"no Filter&gt;&gt;&gt;"</span>);</span><br><span class="line">            filterChain.doFilter(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAjaxRequest</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    	String header = request.getHeader(<span class="string">"X-Requested-With"</span>);</span><br><span class="line">        <span class="keyword">if</span>(header != <span class="keyword">null</span> &amp;&amp; <span class="string">"XMLHttpRequest"</span>.equals(header)) &#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2019/07/14/spring过滤器/" data-id="cjyms8jtg000ndwudyccuoy5u" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-spring拦截器HandlerInterceptor" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2019/07/14/spring拦截器HandlerInterceptor/" class="article-date">
  <time datetime="2019-07-14T02:25:45.000Z" itemprop="datePublished">2019-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2019/07/14/spring拦截器HandlerInterceptor/">spring拦截器HandlerInterceptor</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>拦截器是基于web框架的调用，因此可以使用spring的依赖注入（DI）进行一些业务操作。在springMVC中就是依赖于springMVC框架。在实现上基于Java的反射机制，属于面向切面编程（AOP）的一种运用。</p>
<h4 id="主要工作场景"><a href="#主要工作场景" class="headerlink" title="主要工作场景"></a>主要工作场景</h4><p>拦截器可以获取IOC容器中的各个bean，而过滤器就不行，所以在拦截器里注入一个service，可以调用业务逻辑。</p>
<font color="red">拦截器只能对controller请求进行拦截，对其他的一些比如直接访问静态资源的请求则没办法进行拦截处理。</font>

<h4 id="WebMvcConfigurerAdapter比较常用的重写接口"><a href="#WebMvcConfigurerAdapter比较常用的重写接口" class="headerlink" title="WebMvcConfigurerAdapter比较常用的重写接口"></a>WebMvcConfigurerAdapter比较常用的重写接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 添加类型转换器和格式化器 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFormatters</span><span class="params">(FormatterRegistry registry)</span></span></span><br><span class="line"><span class="function"><span class="comment">/** 配置消息转换器 */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span></span></span><br><span class="line"><span class="function"><span class="comment">/** 解决跨域问题 */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span></span>;</span><br><span class="line"><span class="comment">/** 添加拦截器 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span></span>;</span><br><span class="line"><span class="comment">/** 这里配置视图解析器 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">configureVeiwResolvers</span><span class="params">(ViewResolverRegistry registry)</span></span>;</span><br><span class="line"><span class="comment">/** 配置内容裁决的一些选项 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">configureContentNegotiation</span><span class="params">(ContentNegotiationConfigurer configurer)</span></span>;</span><br><span class="line"><span class="comment">/** 视图跳转控制器 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addViewVontrollers</span><span class="params">(ViewControllerRegistry registry)</span></span>;</span><br><span class="line"><span class="comment">/** 静态资源处理 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span></span>;</span><br><span class="line"><span class="comment">/** 默认静态资源处理器 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span></span>;</span><br></pre></td></tr></table></figure>
<p>#添加拦截器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">	registry.addInterceptor(<span class="keyword">new</span> ReqInterceptor()).addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="实现自定义拦截器"><a href="#实现自定义拦截器" class="headerlink" title="实现自定义拦截器"></a>实现自定义拦截器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReqInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">"拦截器--preHandle"</span>)；</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.preHandle(request, response, handler);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">"拦截器--postHandle"</span>);</span><br><span class="line">        <span class="keyword">super</span>.postHandle(request, response, handler, modelAndView);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Excepion </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">"拦截器--afterCompletion"</span>);</span><br><span class="line">        <span class="keyword">super</span>.afterCompletion(request, response, handler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterConcurrentHandlingStarted</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">"拦截器--afterConcurrentHandlingStarted"</span>);</span><br><span class="line">        <span class="keyword">super</span>.afterConcurrentHandlingStarted(request, response, handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2019/07/14/spring拦截器HandlerInterceptor/" data-id="cjyms8jte000mdwud5da3cac7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-elasticsearch全文搜索探究（多词查询）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2019/07/13/elasticsearch全文搜索探究（多词查询）/" class="article-date">
  <time datetime="2019-07-13T08:16:22.000Z" itemprop="datePublished">2019-07-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2019/07/13/elasticsearch全文搜索探究（多词查询）/">elasticsearch全文搜索探究（多词查询）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="多词查询"><a href="#多词查询" class="headerlink" title="多词查询"></a>多词查询</h3><p>如果我们一次只能搜索一个词，那么全文搜索就会不太灵活，幸运的是match查询让多词变得简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">	&quot;query&quot;:&#123;</span><br><span class="line">    	&quot;match&quot;:&#123;</span><br><span class="line">        	&quot;title&quot;:&quot;BROWN DOG!&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这个查询返回所有四个文档：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;hits&quot;:[</span><br><span class="line">    	&#123;</span><br><span class="line">        	&quot;_id&quot;: &quot;4&quot;,</span><br><span class="line">            &quot;_score&quot;: 0.73185337,</span><br><span class="line">            &quot;_source&quot;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为match查询必须查找两个词，它在内部实际上先执行两次term查询，然后将两次查询的结果合并作为最终结果输出。为了做到这点，它将两个term查询包入一个bool查询中。</p>
<h4 id="提高精度"><a href="#提高精度" class="headerlink" title="提高精度"></a>提高精度</h4><p>用任意查询词项匹配文档可能会导致结果中出现不相关的长尾。这是种散弹式搜索。可能我们只想搜索包含所有词项的文档，也就是说，不去匹配brown OR dog，而通过匹配brown AND dog找到所有文档。match查询还可以接受operator操作符作为输入参数，默认情况下该操作是or。可以修改成and让所有指定词项都必须匹配：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"query"</span>:&#123;</span><br><span class="line">    	<span class="string">"match"</span>:&#123;</span><br><span class="line">        	<span class="string">"title"</span>:&#123;</span><br><span class="line">            	<span class="string">"query"</span>:<span class="string">"BROWN DOG!"</span>,</span><br><span class="line">                <span class="string">"operator"</span>:<span class="string">"and"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="控制精度"><a href="#控制精度" class="headerlink" title="控制精度"></a>控制精度</h4><p>在所有与任意间二选一有点过于非黑即白。如果用户给定5个查询词项，想查找只包含其中4个的文档，该如何处理？</p>
<p>match查询支持minimum_should_match最小匹配参数，这让我们可以指定必须匹配的词项数用来表示一个文档是否相关。我们可以将其设置为某个具体数字，更常用的做法是将其设置为一个百分数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"query"</span>:&#123;</span><br><span class="line">    	<span class="string">"match"</span>:&#123;</span><br><span class="line">        	<span class="string">"title"</span>:&#123;</span><br><span class="line">            	<span class="string">"query"</span>:<span class="string">"quick brown dog"</span>,</span><br><span class="line">                <span class="string">"minimum_should_match"</span>:<span class="string">"75%"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当给定百分比的时候。minimum_should_match会做合适的事情：在之前三词项的示例中，75%会自动被截断成66.6%。即三个里面两个词。无论这个值设置成什么，至少包含一个词项的文档才会被认为是匹配的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2019/07/13/elasticsearch全文搜索探究（多词查询）/" data-id="cjyms8jsw000idwude86bebot" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-elasticsearch全文搜索探究（匹配查询）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2019/07/13/elasticsearch全文搜索探究（匹配查询）/" class="article-date">
  <time datetime="2019-07-13T07:14:47.000Z" itemprop="datePublished">2019-07-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2019/07/13/elasticsearch全文搜索探究（匹配查询）/">elasticsearch全文搜索探究（匹配查询）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="匹配查询"><a href="#匹配查询" class="headerlink" title="匹配查询"></a>匹配查询</h3><p>匹配查询match是个核心查询。无论需要查询什么字段，match查询都应该会是首选的查询方式。它是一个高级全文查询，这表示它既能处理全文字段，又能处理精确字段。</p>
<p>这就是说，match查询主要的应用场景就是进行全文搜索。</p>
<h4 id="索引一些数据"><a href="#索引一些数据" class="headerlink" title="索引一些数据"></a>索引一些数据</h4><p>首先使用bulk API创建一些新的文档和索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DELETE /my_index</span><br><span class="line">PUT /my_index</span><br><span class="line">&#123;&quot;settings&quot;:&#123;&quot;number_of_shards&quot;:1&#125;&#125;</span><br><span class="line"></span><br><span class="line">POST /my_index/my_type/_bulk</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_id&quot;:1&#125;&#125;</span><br><span class="line">&#123;&quot;title&quot;:&quot;The quick brown fox&quot;&#125;</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_id&quot;:2&#125;&#125;</span><br><span class="line">&#123;&quot;title&quot;:&quot;The quick brown fox&quot;&#125;</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_id&quot;:3&#125;&#125;</span><br><span class="line">&#123;&quot;title&quot;:&quot;The quick brown fox&quot;&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="单个词查询"><a href="#单个词查询" class="headerlink" title="单个词查询"></a>单个词查询</h4><p>我们用第一个示例来解释使用match查询搜索全文字段中的单个词：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">	&quot;query&quot;:&#123;</span><br><span class="line">    	&quot;match&quot;:&#123;&quot;title&quot;:&quot;QUICK!&quot;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>elasticsearch执行上面这个match查询的步骤是：</p>
<ol>
<li>检查字段类型。</li>
</ol>
<p>标题title字段是一个string类型（analyzed）已分析的全文字段，这意味着查询字符串本身也应该被分析。</p>
<ol start="2">
<li>分析查询字符串。</li>
</ol>
<p>将查询的字符串QUICK！传入标准分析器，输出的结果是单个项quick。因为只有一个单词项，所以match查询执行的是单个底层term查询。</p>
<ol start="3">
<li>查找匹配文档。</li>
</ol>
<p>用term查询在倒排索引中查找quick然后获取一组包含该项的文档。</p>
<ol start="4">
<li>为每个文档评分。</li>
</ol>
<p>用term查询计算每个文档相关度评分_score，这是种将词频和反向文档频率，以及字段的长度相结合的计算方式。</p>
<p>这个过程给我们以下结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&quot;hits&quot;:[</span><br><span class="line">&#123;</span><br><span class="line">	&quot;_id&quot;:&quot;1&quot;,</span><br><span class="line">    &quot;_score&quot;:0.5,</span><br><span class="line">    &quot;_source&quot;:&#123;</span><br><span class="line">    	&quot;title&quot;:&quot;The quick brown fox&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">	&quot;_id&quot;:&quot;2&quot;,</span><br><span class="line">    &quot;_score&quot;:0.44194174,</span><br><span class="line">    &quot;_source&quot;:&#123;</span><br><span class="line">    	&quot;title&quot;:&quot;The quick brown fox&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<ol>
<li>文档1最相关，因为它的title字段更短，即quick占据内容的一大部分。</li>
<li>文档3比文档2更具有相关性，因为在文档3中quick出现两次。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2019/07/13/elasticsearch全文搜索探究（匹配查询）/" data-id="cjyms8jsg000fdwud2i4osqkl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Collections解读" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2019/06/20/Collections解读/" class="article-date">
  <time datetime="2019-06-20T13:22:32.000Z" itemprop="datePublished">2019-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2019/06/20/Collections解读/">Collections解读</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>sort<br>对集合进行排序<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; <span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在使用List时想根据List中存储对象的某一字段进行排序，那么我们要用到Collections.sort方法对list排序，用Collections.sort方法对list排序有两种：</p>
<ol>
<li>第一种是list中的对象实现Comparable接口；</li>
<li>第二种方法是根据Collections.sort重载方法来实现。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2019/06/20/Collections解读/" data-id="cjyms8jqe0000dwud4ow8v7sp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java并发之AQS详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2019/06/18/Java并发之AQS详解/" class="article-date">
  <time datetime="2019-06-18T15:10:58.000Z" itemprop="datePublished">2019-06-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2019/06/18/Java并发之AQS详解/">Java并发之AQS详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>AbstractQueuedSynchronizer（抽象的队列式的同步器），AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch。</p>
<h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p><img src="/lfhboke.github.io/css/images/aqs1.PNG" alt="aqs1"><br>它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里volatile是核心关键词。state的访问方式有三种：</p>
<ol>
<li>getState()</li>
<li>setState()</li>
<li>compareAndSetState()<br>AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。</li>
</ol>
<p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护，AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p>
<ol>
<li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li>
<li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li>
<li>tryRelease(int)：共享方式。尝试释放资源，成功则返回true，失败则返回false。</li>
<li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>
<li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。<h3 id="设计与结构"><a href="#设计与结构" class="headerlink" title="设计与结构"></a>设计与结构</h3><h4 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h4>同步器的核心方法是acquire和release操作，其背后的思想也比较简洁明确。acquire操作是这样的：while (当前同步器的状态不允许获取操作) {<br> 如果当前线程不在队列中，则将其插入队列阻塞当前线程<br>}</li>
</ol>
<p>如果线程位于队列中，则将其移出队列</p>
<p>release操作是这样的：</p>
<p>更新同步器的状态</p>
<p>if(新的状态允许某个被阻塞的线程获取成功)</p>
<pre><code>接触队列中一个或多个线程的阻塞状态
</code></pre><p>从这两个操作中的思想中我们可以提取三大关键操作：同步器的状态变更、线程阻塞和释放、插入和移出队列。所以为了实现这两个操作，需要协调三大关键操作引申出来的三个基本组件：</p>
<ol>
<li>同步器状态的原子性管理；</li>
<li>线程阻塞与解除阻塞；</li>
<li>队列的管理；<h5 id="同步状态"><a href="#同步状态" class="headerlink" title="同步状态"></a>同步状态</h5>AQS类使用单个int（32位）来保存同步状态，并暴露出getState、setState以及compareAndSetState操作来读取和更新这个同步状态。其中属性state被声明为volatile，并且通过使用CAS指令来实现compareAndSetState，使得当且仅当同步状态拥有一个一致的期望值的时候，才会被原子地设置成新值，这样就达到了同步状态的原子性管理，确保了同步状态的原子性、可见性和有序性。</li>
</ol>
<p>基于AQS的具体实现类必须根据暴露出的状态相关的方法定义tryAcquire和tryRelease方法，以控制acquire和release操作。当同步状态满足时，tryAcquire方法必须返回true，而当新的同步状态允许后续acquire时，tryRelease方法也必须返回true。这些方法都接受一个int类型的参数用于传递想要的状态。</p>
<h5 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h5><p>直到JSR166，阻塞线程和解除线程阻塞都是基于Java的内置管程，没有其它非基于Java内置管程的API可以用来达到阻塞线程和解除线程阻塞。唯一可以选择的是Thread.suspend和Thread.resume，但是它们都有无法解决的竞态问题，所以也没法用。</p>
<p>juc locks包提供了LockSupport类来解决这个问题。方法LockSupport.park阻塞当前线程直到有个LockSupport.unpark方法被调用。unpark的调用是没有被计数的，因此在一个park调用前多次调用unpark方法只会解除一个park操作。另外，它们作用于每个线程而不是每个同步器。一个线程在一个新的同步器上调用park操作可能会立即返回，因为在此之前可以有多余的unpark操作。但是，在缺少一个unpark操作时，下一次调用park就会阻塞。虽然可以显式地取消多余的unpark调用，但并不值得这样做。在需要的时候多次调用park会更高效。park方法同样支持可选的相对或绝对的超时设置，以及与JVM的Thread.interrupt结合，可通过中断来unpark一个线程。</p>
<h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p>整个框架的核心就是如何管理线程阻塞队列，该队列是严格的FIFO队列，因此不支持线程优先级的同步。同步队列的最佳选择是自身没有使用底层锁来构造的非阻塞数据结构，业界主要有两种选择，一种是MCS锁，另一种是CLH锁。其中CLH一般用于自旋，但是相比MCS，CLH更容易实现取消和超时，所以同步队列选择了CLH作为实现的基础。</p>
<p>CLH队列实际并不那么像队列，它的出队和入队与实际的业务使用场景密切相关。它是一个链表队列，通过AQS的两个字段head(头节点)和tail(尾节点)来存取，这两个字段是volatile类型，初始化的时候都指向了一个空节点。<br><img src="/lfhboke.github.io/css/images/head.PNG" alt="head"><br>入队操作：CLH队列是FIFO队列，故新的节点到来的时候，是要插入到当前队列的尾节点之后。试想一下哎，当一个线程成功地获取了同步状态，其他线程将无法获取到同步状态，转而被构造成为节点并加入到同步队列中，而这个加入队列的过程必须要保证线程安全，因此同步器提供了一个CAS方法，它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。入队操作示意图大致如下：<br><img src="/lfhboke.github.io/css/images/head2.PNG" alt="head2"><br>出队操作：因为遵循FIFO规则，所以能成功获取到AQS同步状态的必定是首节点，首节点的线程在释放同步状态时，会唤醒后续节点，而后续节点会在获取AQS同步状态成功的时候将自己设置为首节点。设置首节点是由获取同步成功的线程来完成的，由于只能有一个线程可以获取到同步状态，所以设置首节点的方法不需要像入队这样的CAS操作，只需要将首节点设置为原首节点的后续节点同时断开原节点、后续节点同时断开原节点、后续节点的引用即可。出队示意图如下：<br><img src="/lfhboke.github.io/css/images/head3.PNG" alt="head3"></p>
<h5 id="条件队列"><a href="#条件队列" class="headerlink" title="条件队列"></a>条件队列</h5><p>其实是AQS的同步队列，这一节的队列是条件队列，队列的管理除了有同步队列，还有条件队列。AQS只有一个同步队列，但是可以有多个条件队列。AQS框架提供了一个ConditionObject类，给维护独占同步的类以及实现Lock接口的类使用。</p>
<p>ConditionObject类实现了Condition接口，Condition接口提供了类似Object管程式的方法，如await、signal和signal All操作，还扩展了带有超时、检测和监控的方法。ConditionObject类有效地将条件与其他同步操作结合到了一起。该类只支持Java风格的管程访问规则，这些规则中，当且仅当当前线程持有锁且要操作的条件（condition）属于该锁时，条件操作才是合法的。这样，一个ConditionObject关联到一个ReentrantLock上就表现的跟内置的管程一样了。两者不同仅仅在于方法的名称、额外的功能以及用户可以为每个锁声明多个条件。</p>
<p>ConditionObject类和AQS共用了内部节点，有自己单独的条件队列。signal操作是通过将节点从条件队列转移到同步队列中来实现的，没有必要在需要唤醒的线程重新获取到锁之前将其唤醒。signal操作大致示意图如下：<br><img src="/lfhboke.github.io/css/images/signal.PNG" alt="signal"><br>await操作就是当前线程节点从同步队列进入条件队列进行等待，大致如下：<br><img src="/lfhboke.github.io/css/images/signal1.PNG" alt="signal1"><br>实现这些操作主要复杂在，因超时或Thread.interrupt导致取消了条件等待时，该如何处理。await和signal几乎同时发生就会有竞态问题，最终的结果遵照内置管程相关规范。JSR133修订以后，就要求如果中断发生在signal操作之前，await方法必须在重新获取到锁后，抛出InterruptedException。但是，如果中断发生在signal后，await必须返回且不抛异常，同时设置线程的中断状态。</p>
<h4 id="方法结构"><a href="#方法结构" class="headerlink" title="方法结构"></a>方法结构</h4><p>大致可以直到AQS的主要数据结构：</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>数据结构</th>
</tr>
</thead>
<tbody>
<tr>
<td> 同步状态</td>
<td>volatile int state</td>
</tr>
<tr>
<td> 阻塞</td>
<td>LockSupport类</td>
</tr>
<tr>
<td> 队列</td>
<td>Node节点</td>
</tr>
<tr>
<td> 条件队列</td>
<td>ConditionObject</td>
</tr>
</tbody>
</table>
<p> 进而再来看下AQS的主要方法和作用</p>
<table>
<thead>
<tr>
<th>属性、方法</th>
<th>描述、作用</th>
</tr>
</thead>
<tbody>
<tr>
<td> int getState()</td>
<td>获取当前同步状态</td>
</tr>
<tr>
<td> void setState(int newState)</td>
<td>设置当前同步状态</td>
</tr>
<tr>
<td> boolean compareAndSetState(int expect, int update)</td>
<td>通过CAS设置当前状态，此方法保证状态设置的原子性</td>
</tr>
<tr>
<td> boolean tryAcquire(int arg)</td>
<td>钩子方阿飞，独占式获取同步状态，AQS没有具体实现，具体实现都在子类中，实现此方法需要查询当前同步状态并判断同步状态是否符合预期，然后再CAS设置同步状态</td>
</tr>
<tr>
<td> boolean tryRelease(int arg)</td>
<td>钩子方法，独占式释放同步状态，AQS没有具体实现，具体实现都在子类中，等待获取同步状态的线程将有机会获取同步状态</td>
</tr>
<tr>
<td> int tryAcquireShared(int arg)</td>
<td>钩子方法，共享式获取同步状态，AQS没有具体实现，具体实现都在子类中，返回大于等于0的值表示获取成功，反之失败</td>
</tr>
<tr>
<td> boolean tryReleaseShare(int arg)</td>
<td>钩子方法，共享式释放同步状态，AQS没有具体实现</td>
</tr>
<tr>
<td> boolean isHeldExclusively()</td>
<td>钩子方法，当前同步器是否在独占模型下被线程占用，一般该方法表示是否被当前线程所独占</td>
</tr>
<tr>
<td> void acquire(int arg)</td>
<td>模板方法，独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则会进入同步队列等待，此方法会调用子类重写的tryAcquire方法</td>
</tr>
<tr>
<td> void acquireInterruptibly(int arg)</td>
<td>模板方法，与acquire相同，但是此方法可以响应中断，当前线程未获取到同步状态而进入同步队列中，如果当前线程被中断，此方法会抛出InterruptedException并返回</td>
</tr>
<tr>
<td>boolean tryAcquireNanos(int arg, long nanosTimeout)</td>
<td>模板方法，在acquireInterryptibly基础上增加了超时限制，如果当前线程在超时时间内没有获取到同步状态，则会返回false，如果获取到了则会返回true</td>
</tr>
<tr>
<td>boolean release(int arg)</td>
<td>模板方法，独占式的释放同步状态，该方法会在释放同步状态后，将同步队列中的第一个节点包含的线程唤醒</td>
</tr>
<tr>
<td>void acquireShared(int arg)</td>
<td>模板方法，共享式的获取同步状态，如果当前系统未获取到同步状态，将会进入同步队列等待，与acquire的主要区别在于同一时刻可以有多个线程获取到同步状态</td>
</tr>
<tr>
<td>void acquireSharedInterruptibly(int arg)</td>
<td>模板方法，与acquireShared一致，但是可以响应中断</td>
</tr>
<tr>
<td>boolean tryAcquireSharedNanos(int arg, long nanosTimeout)</td>
<td>模板方法，在acquireSharedInterruptibly基础上增加了超时限制</td>
</tr>
<tr>
<td>boolean releaseShared(int arg)</td>
<td>模板方法，共享式的释放同步状态</td>
</tr>
<tr>
<td>Collection\&lt;Thread> getQueuedThreads()</td>
<td>模板方法，获取等待在同步队列上的线程集合</td>
</tr>
<tr>
<td>Node int waitStatus</td>
<td>等待状态</td>
</tr>
<tr>
<td>Node prev</td>
<td>前驱节点，当节点加入同步队列时被设置</td>
</tr>
<tr>
<td>Node next</td>
<td>后续节点</td>
</tr>
<tr>
<td>Thread thread</td>
<td>获取同步状态的线程</td>
</tr>
<tr>
<td>Node nextWaiter</td>
<td>条件队列中的后续节点，如果当前节点是共享的，那么这个字段将是一个SHARED变量，也就是说节点类型和条件队列中的后续节点共用同一个字段</td>
</tr>
<tr>
<td>LockSupport void park()</td>
<td>阻塞当前线程，如果调用unpark方法或者当前线程被中断，才能从park方法返回</td>
</tr>
<tr>
<td>LockSupport void unpark(Thread thread)</td>
<td>唤醒处于阻塞状态的线程</td>
</tr>
<tr>
<td>ConditionObject Node firstWaiter</td>
<td>条件队列首节点</td>
</tr>
<tr>
<td>ConditionObject Node lastWaiter</td>
<td>条件队列尾节点</td>
</tr>
<tr>
<td>void await()</td>
<td>当前线程进入等待状态直到signal或中断，当前线程将进入运行状态且从await方法返回的情况，包括：其他线程调用该Condition的signal或者signalAll方法，且当前线程被选中唤醒；其他线程调用interrupt方法中断当前线程；如果当前线程从await方法返回表明该现层已经获取了Condition对象对应的锁</td>
</tr>
<tr>
<td>void awaitUninterruptibly()</td>
<td>和await方法类似，但是中断不敏感</td>
</tr>
<tr>
<td>long awaitNanos(long nanosTimeout)</td>
<td>当前线程进入等待状态直到被signal、中断或者超时。返回值表示剩余的时间。</td>
</tr>
<tr>
<td>boolean awaitUntil(Date deadline)</td>
<td>当前线程进入等待状态直到被signal、中断或者某个时间。如果没有到指定时间就被通知，方法返回true，否则表示到了指定时间，返回false</td>
</tr>
<tr>
<td>void signal()</td>
<td>唤醒一个等待在Condition上的线程，该线程从等待方法返回前必须获得与Condition相关联的锁</td>
</tr>
<tr>
<td>void signalAll()</td>
<td>唤醒所有等待在Condition上的线程，能够从等待方法返回的线程必须获得与Condition相关联的锁</td>
</tr>
</tbody>
</table>
<h3 id="AQS的源代码实现"><a href="#AQS的源代码实现" class="headerlink" title="AQS的源代码实现"></a>AQS的源代码实现</h3><p>主要通过独占式同步状态的获取和释放、共享式同步状态的获取和释放。</p>
<h4 id="独占式同步状态的获取和释放"><a href="#独占式同步状态的获取和释放" class="headerlink" title="独占式同步状态的获取和释放"></a>独占式同步状态的获取和释放</h4><p>独占式同步状态调用的方法是acquire，代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>( !tryAcquire(arg) &amp;&amp; acquireQueued( addWaiter( Node.EXCLUSIVE ), arg ) )</span><br><span class="line">    	selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码主要完成了同步状态获取、节点构造、加入同步队列以及在同步队列中自旋等待的相关工作，其主要逻辑是：首先调用子类实现的tryAcquire方法，该方法保证线程安全的获取同步状态，如果同步状态获取失败，则构造独占式同步节点（同一时刻只能有一个线程成功获取同步状态）并通过addWaiter方法将该节点加入到同步队列的尾部，最后调用acquireQueued方法，使得该节点以自旋的方式获取同步状态。如果获取不到则阻塞节点中的线程，而被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现。</p>
<p>下面来首先看下节点构造和加入同步队列是如何实现的。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//当前线程构造成Node节点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">//尝试快速在尾节点后新增节点提升算法效率 先将尾节点指向pred</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span>(pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">    	<span class="comment">//尾节点不为空 当前线程节点的前驱节点指向尾节点</span></span><br><span class="line">        Node.prev = pred;</span><br><span class="line">        <span class="comment">//并发处理 尾节点有可能已经不是之前的节点，所以需要CAS更新</span></span><br><span class="line">        <span class="keyword">if</span>( compareAndSetTail(pred, node) ) &#123;</span><br><span class="line">        	<span class="comment">//CAS更新成功 当前线程为尾节点 原先尾节点的后续节点就是当前节点</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第一个入队的节点或者是尾节点后续节点新增失败时进入enq</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    	Node t = tail;</span><br><span class="line">        <span class="keyword">if</span>( t == <span class="keyword">null</span> ) &#123;</span><br><span class="line">        	<span class="comment">//尾节点为空 第一次入队 设置头尾节点一致 同步队列的初始化</span></span><br><span class="line">            <span class="keyword">if</span>(compareAndSetHead( <span class="keyword">new</span> Node() )) &#123;</span><br><span class="line">            	tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="comment">//所有线程节点在构造完第一个节点后 依次加入到同步队列中</span></span><br><span class="line">            	node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> ( compareAndSetTail(t, node) ) &#123;</span><br><span class="line">                	t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>节点进入同步队列之后，就进入了一个自旋的过程，每个线程节点都在自省地观察，当条件满足，获取到了同步状态，就可以从这个自旋过程中退出，否则依旧留在这个自旋过程中并会阻塞节点的线程，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">    	<span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        	<span class="comment">//获取当前线程节点的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//前驱节点为头节点且成功获取同步状态</span></span><br><span class="line">            <span class="keyword">if</span>( p == head &amp;&amp; tryAcquire(arg) ) &#123;</span><br><span class="line">            	<span class="comment">//设置当前节点为头节点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">//help GC</span></span><br><span class="line">                p.next = <span class="keyword">null</span>;</span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//是否阻塞</span></span><br><span class="line">            <span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node)  &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">            	interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(failed) &#123;</span><br><span class="line">        	cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再来看看shouldParkAfterFailedAcquire和parkAndCheckInterrupt是怎么来阻塞当前线程的，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//前驱节点的状态决定后续节点的行为</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span>(ws = Node.SIGNAL) &#123;</span><br><span class="line">    	<span class="comment">//前驱节点为-1，后续节点可以被阻塞</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="keyword">do</span>&#123;</span><br><span class="line">        	node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> ( pred.waitStatus &gt; <span class="number">0</span> );</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">//当前节点是初始或者共享状态就设置为-1，使后续节点阻塞</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//阻塞线程</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当同步状态获取成功之后，当前线程从acquire方法返回，对于锁这种并发组建而言，就意味着当前线程获取了锁。有获取同步状态的方法，就存在其对应的释放方法，该方法为release，现在来看下这个方法的实现，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 同步状态释放成功</span></span><br><span class="line">	<span class="keyword">if</span>( tryReleas(arg) ) &#123;</span><br><span class="line">    	Node h = head;</span><br><span class="line">        <span class="keyword">if</span>( h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span> ) &#123;</span><br><span class="line">        	<span class="comment">//直接释放头节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">( Node node )</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span>(ws &lt; <span class="number">0</span>)</span><br><span class="line">    	compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//寻找符合条件的后续节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    	s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(Node t = tail; t!= <span class="keyword">null</span> &amp;&amp; t!= node; t=t.prev)</span><br><span class="line">        	<span class="keyword">if</span>(t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">            	s=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s!=<span class="keyword">null</span>)</span><br><span class="line">    	<span class="comment">//唤醒后续节点</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>独占式释放四非常简单而且明确的。</p>
<p>总结：在获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋；移出队列的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用tryRelease方法释放同步状态，然后唤醒头节点的后继节点。</p>
<h4 id="共享式同步状态的获取和释放"><a href="#共享式同步状态的获取和释放" class="headerlink" title="共享式同步状态的获取和释放"></a>共享式同步状态的获取和释放</h4><p>共享式同步状态调用的方法是acquireShared，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获取同步状态的返回值大于等于0时表示可以获取同步状态</span></span><br><span class="line">    <span class="comment">//小于0表示可以获取步到同步状态，需要进入队列等待</span></span><br><span class="line">    <span class="keyword">if</span>(tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">    	doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//独占式一样的入队操作</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">    	<span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//自旋</span></span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        	<span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span>(p == head) &#123;</span><br><span class="line">            	<span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span>(r &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                	<span class="comment">//前驱节点为头节点且成功获取同步状态 可退出自旋</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (interrupted) </span><br><span class="line">                    	selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">            interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(failed)</span><br><span class="line">        	cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">	Node h = head;</span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="keyword">if</span>(propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    	Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.isShared()) &#123;</span><br><span class="line">        	doReleaseShared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>共享式获取也需要释放同步状态<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//释放同步状态</span></span><br><span class="line">    <span class="keyword">if</span>(tryReleaseShared(arg)) &#123;</span><br><span class="line">    	<span class="comment">//唤醒后续等待的节点</span></span><br><span class="line">        doRleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    	Node h = head;</span><br><span class="line">        <span class="keyword">if</span>(h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">        	<span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span>(ws == Node.SIGNAL) &#123;</span><br><span class="line">            	<span class="keyword">if</span>(!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                	<span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//唤醒后续节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ws == <span class="number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="number">0</span>, NodePROPAGATE))</span><br><span class="line">            	<span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(h == head) </span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2019/06/18/Java并发之AQS详解/" data-id="cjyms8jwb0013dwud31omhdcp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java并发工具类之LongAdder" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2019/06/17/Java并发工具类之LongAdder/" class="article-date">
  <time datetime="2019-06-17T14:28:40.000Z" itemprop="datePublished">2019-06-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2019/06/17/Java并发工具类之LongAdder/">Java并发工具类之LongAdder</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>LongAdder是Java8新出的工具类，个人认为是一个以牺牲空间换取性能的工具。<br><img src="/lfhboke.github.io/css/images/atomiclong.PNG" alt="AtomicLong"><br>下面是LongAdder<br><img src="/lfhboke.github.io/css/images/longadder.PNG" alt="LongAdder"><br>是将一个变量进一步拆分到一个base数组中，减少资源竞争<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cell</span></span>&#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">    Cell(<span class="keyword">long</span> x) &#123;</span><br><span class="line">    	value = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">cas</span><span class="params">(<span class="keyword">long</span> cmp, <span class="keyword">long</span> val)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, valueOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123; </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">      	UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; ak = Cell.class;</span><br><span class="line">        valueOffset = UNSAFE.objectFieldOffset(ak.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">      &#125; <span class="keyword">catch</span>( Exception e ) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>类似于AtomicLong，利用CAS来更新变量</li>
<li>@Contended避免value伪共享</li>
</ol>
<p>将多个cell数组中的值加起来的和就类似于AtomicLong中的value<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Cell[] as = cells;</span><br><span class="line">    Cell a;</span><br><span class="line">    <span class="keyword">long</span> sum = base;</span><br><span class="line">    <span class="keyword">if</span> ( as != <span class="keyword">null</span> ) &#123;</span><br><span class="line">    	<span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i ) &#123;</span><br><span class="line">        	<span class="keyword">if</span> ( ( a = as[i] != <span class="keyword">null</span> ) ) &#123;</span><br><span class="line">            	sum += a.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>increment()的调用链<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.atomic.LongAdder.increment</span><br><span class="line">-&gt;java.util.concurrent.atomic.LongAdder.add</span><br></pre></td></tr></table></figure></p>
<p><img src="/lfhboke.github.io/css/images/threadprocess.PNG" alt="ThreadProcess"><br>add()方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">	Cell[] as; </span><br><span class="line">    <span class="keyword">long</span> b, v;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    Cell a;</span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> || !casBase(b = base, b+x)) &#123;</span><br><span class="line">    	<span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> ( as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> || (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> || !(uncontended = a.cas( v = a.value, v+x )) ) &#123;</span><br><span class="line">        	longAccumulate(x, <span class="keyword">null</span>, uncontended);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一次Cell数组为空，进入casBase()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">casBase</span><span class="params">(<span class="keyword">long</span> cmp, <span class="keyword">long</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, BASE, cmp, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>即原子更新，成功则直接返回，失败则说明出现并发了if的三个判断</p>
<ol>
<li>数组为空</li>
<li>或者数组长度小于1</li>
<li>或者位置上没有Cell对象，即getProbe()&amp;m其实相当于hashMap里面的tab[i=(n-1)&amp;hash]</li>
<li>或者修改cell的值失败<br>才会最终进入到longAccumulate()方法中<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5></li>
<li>如果Cells表为空，尝试用CAS更新base字段，成功则退出；</li>
<li>如果Cells表为空，CAS更新base字段失败，出现竞争，uncontend为true，调用longAccumulate；</li>
<li>如果Cells表非空，且前线程映射的槽非空，CAS更新Cell的值，成功则返回，否则，uncontended设为false，调用longAccumulate。</li>
</ol>
<p>制约AtomicLong高效的原因是高并发，高并发意味着CAS的失败几率更高，重试次数更多，越多线程重试，CAS失败几率又越高，AtomicLong效率降低。LongAdder通过减少并发，将单一value的更新压力分担到多个value中去，降低单个value的“热度”，分段更新。</p>
<p>这样，线程数再多也会分担到多个value上去更新，只需要增加value就可以降低value的“热度”。cells就是这个“段”cell中的value就是存放更新值。</p>
<p>caseBase操作等价于AtomicLong中的CAS操作，要知道，LongAdder这样的处理方式是有坏处的，分段操作必然带来空间上的浪费，可以空间换时间。</p>
<p>caseBase操作保证了在低并发时，不会立即进入分支做分段更新操作，因为低并发时，caseBase操作基本都会成功，只有并发高到一定程度了，才会进入分支。</p>
<p>longAccumulate()方法如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">longAccumulate</span><span class="params">(<span class="keyword">long</span> x, LongBinaryOperator fn, <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">    	ThreadLocalRandom.current();</span><br><span class="line">        h = getProbe();</span><br><span class="line">        wasUncontended = <span class="keyword">true</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    	Cell[] as; Cell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">        <span class="keyword">if</span>((as = cells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="keyword">if</span> ( (a = as[(n-<span class="number">1</span>)&amp;h]) == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            	<span class="keyword">if</span>(cellsBusy == <span class="number">0</span>) &#123;</span><br><span class="line">                </span><br><span class="line"> 	Cell r = <span class="keyword">new</span> Cell(x);</span><br><span class="line">    <span class="keyword">if</span>(cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">    	<span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">        	Cell[] rs;<span class="keyword">int</span> m, j;</span><br><span class="line">            <span class="keyword">if</span>((rs = cells) != <span class="keyword">null</span> &amp;&amp; (m = rs.length) &gt; <span class="number">0</span> &amp;&amp; rs[j = (m - <span class="number">1</span>)&amp;h] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            	rs[j] = r;</span><br><span class="line">                created = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        	cellsBusy = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(created)</span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    collide = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!wasUncontended)</span><br><span class="line">            	wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a.cas(v = a.value, ((fn == <span class="keyword">null</span>) ?v+x: fn.applyAsLong(v, x))))</span><br><span class="line">            	<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">            	</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>如果Cells表为空，尝试获取锁之后初始化表（初始大小为2）；</li>
<li>如果Cells表非空，对应的Cell为空，自旋锁未被占用，尝试获取锁，添加新的Cell；</li>
<li>如果Cells表非空，找到线程对应的Cell，尝试通过CAS更新该值；</li>
<li>如果Cells表非空，线程对应的Cell CAS更新失败，说明存在竞争，尝试获取自旋锁之后扩容，将cells数组扩大，降低每个cell的并发量后再试</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2019/06/17/Java并发工具类之LongAdder/" data-id="cjyms8jrn0008dwudnljyqlt6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/lfhboke.github.io/page/2/">2</a><a class="page-number" href="/lfhboke.github.io/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/lfhboke.github.io/page/5/">5</a><a class="extend next" rel="next" href="/lfhboke.github.io/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2016/01/">January 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/lfhboke.github.io/2019/07/27/netty入门应用/">netty入门应用</a>
          </li>
        
          <li>
            <a href="/lfhboke.github.io/2019/07/21/netty开篇/">netty开篇</a>
          </li>
        
          <li>
            <a href="/lfhboke.github.io/2019/07/14/web-xml配置文件详解/">web.xml配置文件详解</a>
          </li>
        
          <li>
            <a href="/lfhboke.github.io/2019/07/14/spring过滤器/">spring过滤器</a>
          </li>
        
          <li>
            <a href="/lfhboke.github.io/2019/07/14/spring拦截器HandlerInterceptor/">spring拦截器HandlerInterceptor</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 lfhu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/lfhboke.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="/lfhboke.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/lfhboke.github.io/fancybox/jquery.fancybox.css">
  <script src="/lfhboke.github.io/fancybox/jquery.fancybox.pack.js"></script>


<script src="/lfhboke.github.io/js/script.js"></script>



  </div>
</body>
</html>