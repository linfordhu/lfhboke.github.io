<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>lfh&#39;s bokes</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="lfh&#39;s bokes">
<meta property="og:url" content="https://linfordhu.github.io/lfhboke.github.io/index.html">
<meta property="og:site_name" content="lfh&#39;s bokes">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lfh&#39;s bokes">
  
    <link rel="alternate" href="/lfhboke.github.io/atom.xml" title="lfh&#39;s bokes" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/lfhboke.github.io/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/lfhboke.github.io/" id="logo">lfh&#39;s bokes</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/lfhboke.github.io/">Home</a>
        
          <a class="main-nav-link" href="/lfhboke.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/lfhboke.github.io/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://linfordhu.github.io/lfhboke.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Collections解读" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2019/06/20/Collections解读/" class="article-date">
  <time datetime="2019-06-20T13:22:32.000Z" itemprop="datePublished">2019-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2019/06/20/Collections解读/">Collections解读</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>sort<br>对集合进行排序<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; <span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在使用List时想根据List中存储对象的某一字段进行排序，那么我们要用到Collections.sort方法对list排序，用Collections.sort方法对list排序有两种：</p>
<ol>
<li>第一种是list中的对象实现Comparable接口；</li>
<li>第二种方法是根据Collections.sort重载方法来实现。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2019/06/20/Collections解读/" data-id="cj49du1nj0001l4udp409tvyk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java并发之AQS详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2019/06/18/Java并发之AQS详解/" class="article-date">
  <time datetime="2019-06-18T15:10:58.000Z" itemprop="datePublished">2019-06-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2019/06/18/Java并发之AQS详解/">Java并发之AQS详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>AbstractQueuedSynchronizer（抽象的队列式的同步器），AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch。</p>
<h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p><img src="/lfhboke.github.io/css/images/aqs1.PNG" alt="aqs1"><br>它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里volatile是核心关键词。state的访问方式有三种：</p>
<ol>
<li>getState()</li>
<li>setState()</li>
<li>compareAndSetState()<br>AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。</li>
</ol>
<p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护，AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p>
<ol>
<li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li>
<li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li>
<li>tryRelease(int)：共享方式。尝试释放资源，成功则返回true，失败则返回false。</li>
<li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>
<li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。<h3 id="设计与结构"><a href="#设计与结构" class="headerlink" title="设计与结构"></a>设计与结构</h3><h4 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h4>同步器的核心方法是acquire和release操作，其背后的思想也比较简洁明确。acquire操作是这样的：while (当前同步器的状态不允许获取操作) {<br> 如果当前线程不在队列中，则将其插入队列阻塞当前线程<br>}</li>
</ol>
<p>如果线程位于队列中，则将其移出队列</p>
<p>release操作是这样的：</p>
<p>更新同步器的状态</p>
<p>if(新的状态允许某个被阻塞的线程获取成功)</p>
<pre><code>接触队列中一个或多个线程的阻塞状态
</code></pre><p>从这两个操作中的思想中我们可以提取三大关键操作：同步器的状态变更、线程阻塞和释放、插入和移出队列。所以为了实现这两个操作，需要协调三大关键操作引申出来的三个基本组件：</p>
<ol>
<li>同步器状态的原子性管理；</li>
<li>线程阻塞与解除阻塞；</li>
<li>队列的管理；<h5 id="同步状态"><a href="#同步状态" class="headerlink" title="同步状态"></a>同步状态</h5>AQS类使用单个int（32位）来保存同步状态，并暴露出getState、setState以及compareAndSetState操作来读取和更新这个同步状态。其中属性state被声明为volatile，并且通过使用CAS指令来实现compareAndSetState，使得当且仅当同步状态拥有一个一致的期望值的时候，才会被原子地设置成新值，这样就达到了同步状态的原子性管理，确保了同步状态的原子性、可见性和有序性。</li>
</ol>
<p>基于AQS的具体实现类必须根据暴露出的状态相关的方法定义tryAcquire和tryRelease方法，以控制acquire和release操作。当同步状态满足时，tryAcquire方法必须返回true，而当新的同步状态允许后续acquire时，tryRelease方法也必须返回true。这些方法都接受一个int类型的参数用于传递想要的状态。</p>
<h5 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h5><p>直到JSR166，阻塞线程和解除线程阻塞都是基于Java的内置管程，没有其它非基于Java内置管程的API可以用来达到阻塞线程和解除线程阻塞。唯一可以选择的是Thread.suspend和Thread.resume，但是它们都有无法解决的竞态问题，所以也没法用。</p>
<p>juc locks包提供了LockSupport类来解决这个问题。方法LockSupport.park阻塞当前线程直到有个LockSupport.unpark方法被调用。unpark的调用是没有被计数的，因此在一个park调用前多次调用unpark方法只会解除一个park操作。另外，它们作用于每个线程而不是每个同步器。一个线程在一个新的同步器上调用park操作可能会立即返回，因为在此之前可以有多余的unpark操作。但是，在缺少一个unpark操作时，下一次调用park就会阻塞。虽然可以显式地取消多余的unpark调用，但并不值得这样做。在需要的时候多次调用park会更高效。park方法同样支持可选的相对或绝对的超时设置，以及与JVM的Thread.interrupt结合，可通过中断来unpark一个线程。</p>
<h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p>整个框架的核心就是如何管理线程阻塞队列，该队列是严格的FIFO队列，因此不支持线程优先级的同步。同步队列的最佳选择是自身没有使用底层锁来构造的非阻塞数据结构，业界主要有两种选择，一种是MCS锁，另一种是CLH锁。其中CLH一般用于自旋，但是相比MCS，CLH更容易实现取消和超时，所以同步队列选择了CLH作为实现的基础。</p>
<p>CLH队列实际并不那么像队列，它的出队和入队与实际的业务使用场景密切相关。它是一个链表队列，通过AQS的两个字段head(头节点)和tail(尾节点)来存取，这两个字段是volatile类型，初始化的时候都指向了一个空节点。<br><img src="/lfhboke.github.io/css/images/head.PNG" alt="head"><br>入队操作：CLH队列是FIFO队列，故新的节点到来的时候，是要插入到当前队列的尾节点之后。试想一下哎，当一个线程成功地获取了同步状态，其他线程将无法获取到同步状态，转而被构造成为节点并加入到同步队列中，而这个加入队列的过程必须要保证线程安全，因此同步器提供了一个CAS方法，它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。入队操作示意图大致如下：<br><img src="/lfhboke.github.io/css/images/head2.PNG" alt="head2"><br>出队操作：因为遵循FIFO规则，所以能成功获取到AQS同步状态的必定是首节点，首节点的线程在释放同步状态时，会唤醒后续节点，而后续节点会在获取AQS同步状态成功的时候将自己设置为首节点。设置首节点是由获取同步成功的线程来完成的，由于只能有一个线程可以获取到同步状态，所以设置首节点的方法不需要像入队这样的CAS操作，只需要将首节点设置为原首节点的后续节点同时断开原节点、后续节点同时断开原节点、后续节点的引用即可。出队示意图如下：<br><img src="/lfhboke.github.io/css/images/head3.PNG" alt="head3"></p>
<h5 id="条件队列"><a href="#条件队列" class="headerlink" title="条件队列"></a>条件队列</h5><p>其实是AQS的同步队列，这一节的队列是条件队列，队列的管理除了有同步队列，还有条件队列。AQS只有一个同步队列，但是可以有多个条件队列。AQS框架提供了一个ConditionObject类，给维护独占同步的类以及实现Lock接口的类使用。</p>
<p>ConditionObject类实现了Condition接口，Condition接口提供了类似Object管程式的方法，如await、signal和signal All操作，还扩展了带有超时、检测和监控的方法。ConditionObject类有效地将条件与其他同步操作结合到了一起。该类只支持Java风格的管程访问规则，这些规则中，当且仅当当前线程持有锁且要操作的条件（condition）属于该锁时，条件操作才是合法的。这样，一个ConditionObject关联到一个ReentrantLock上就表现的跟内置的管程一样了。两者不同仅仅在于方法的名称、额外的功能以及用户可以为每个锁声明多个条件。</p>
<p>ConditionObject类和AQS共用了内部节点，有自己单独的条件队列。signal操作是通过将节点从条件队列转移到同步队列中来实现的，没有必要在需要唤醒的线程重新获取到锁之前将其唤醒。signal操作大致示意图如下：<br><img src="/lfhboke.github.io/css/images/signal.PNG" alt="signal"><br>await操作就是当前线程节点从同步队列进入条件队列进行等待，大致如下：<br><img src="/lfhboke.github.io/css/images/signal1.PNG" alt="signal1"><br>实现这些操作主要复杂在，因超时或Thread.interrupt导致取消了条件等待时，该如何处理。await和signal几乎同时发生就会有竞态问题，最终的结果遵照内置管程相关规范。JSR133修订以后，就要求如果中断发生在signal操作之前，await方法必须在重新获取到锁后，抛出InterruptedException。但是，如果中断发生在signal后，await必须返回且不抛异常，同时设置线程的中断状态。</p>
<h4 id="方法结构"><a href="#方法结构" class="headerlink" title="方法结构"></a>方法结构</h4><p>大致可以直到AQS的主要数据结构：</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>数据结构</th>
</tr>
</thead>
<tbody>
<tr>
<td> 同步状态</td>
<td>volatile int state</td>
</tr>
<tr>
<td> 阻塞</td>
<td>LockSupport类</td>
</tr>
<tr>
<td> 队列</td>
<td>Node节点</td>
</tr>
<tr>
<td> 条件队列</td>
<td>ConditionObject</td>
</tr>
</tbody>
</table>
<p> 进而再来看下AQS的主要方法和作用</p>
<table>
<thead>
<tr>
<th>属性、方法</th>
<th>描述、作用</th>
</tr>
</thead>
<tbody>
<tr>
<td> int getState()</td>
<td>获取当前同步状态</td>
</tr>
<tr>
<td> void setState(int newState)</td>
<td>设置当前同步状态</td>
</tr>
<tr>
<td> boolean compareAndSetState(int expect, int update)</td>
<td>通过CAS设置当前状态，此方法保证状态设置的原子性</td>
</tr>
<tr>
<td> boolean tryAcquire(int arg)</td>
<td>钩子方阿飞，独占式获取同步状态，AQS没有具体实现，具体实现都在子类中，实现此方法需要查询当前同步状态并判断同步状态是否符合预期，然后再CAS设置同步状态</td>
</tr>
<tr>
<td> boolean tryRelease(int arg)</td>
<td>钩子方法，独占式释放同步状态，AQS没有具体实现，具体实现都在子类中，等待获取同步状态的线程将有机会获取同步状态</td>
</tr>
<tr>
<td> int tryAcquireShared(int arg)</td>
<td>钩子方法，共享式获取同步状态，AQS没有具体实现，具体实现都在子类中，返回大于等于0的值表示获取成功，反之失败</td>
</tr>
<tr>
<td> boolean tryReleaseShare(int arg)</td>
<td>钩子方法，共享式释放同步状态，AQS没有具体实现</td>
</tr>
<tr>
<td> boolean isHeldExclusively()</td>
<td>钩子方法，当前同步器是否在独占模型下被线程占用，一般该方法表示是否被当前线程所独占</td>
</tr>
<tr>
<td> void acquire(int arg)</td>
<td>模板方法，独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则会进入同步队列等待，此方法会调用子类重写的tryAcquire方法</td>
</tr>
<tr>
<td> void acquireInterruptibly(int arg)</td>
<td>模板方法，与acquire相同，但是此方法可以响应中断，当前线程未获取到同步状态而进入同步队列中，如果当前线程被中断，此方法会抛出InterruptedException并返回</td>
</tr>
<tr>
<td>boolean tryAcquireNanos(int arg, long nanosTimeout)</td>
<td>模板方法，在acquireInterryptibly基础上增加了超时限制，如果当前线程在超时时间内没有获取到同步状态，则会返回false，如果获取到了则会返回true</td>
</tr>
<tr>
<td>boolean release(int arg)</td>
<td>模板方法，独占式的释放同步状态，该方法会在释放同步状态后，将同步队列中的第一个节点包含的线程唤醒</td>
</tr>
<tr>
<td>void acquireShared(int arg)</td>
<td>模板方法，共享式的获取同步状态，如果当前系统未获取到同步状态，将会进入同步队列等待，与acquire的主要区别在于同一时刻可以有多个线程获取到同步状态</td>
</tr>
<tr>
<td>void acquireSharedInterruptibly(int arg)</td>
<td>模板方法，与acquireShared一致，但是可以响应中断</td>
</tr>
<tr>
<td>boolean tryAcquireSharedNanos(int arg, long nanosTimeout)</td>
<td>模板方法，在acquireSharedInterruptibly基础上增加了超时限制</td>
</tr>
<tr>
<td>boolean releaseShared(int arg)</td>
<td>模板方法，共享式的释放同步状态</td>
</tr>
<tr>
<td>Collection\&lt;Thread> getQueuedThreads()</td>
<td>模板方法，获取等待在同步队列上的线程集合</td>
</tr>
<tr>
<td>Node int waitStatus</td>
<td>等待状态</td>
</tr>
<tr>
<td>Node prev</td>
<td>前驱节点，当节点加入同步队列时被设置</td>
</tr>
<tr>
<td>Node next</td>
<td>后续节点</td>
</tr>
<tr>
<td>Thread thread</td>
<td>获取同步状态的线程</td>
</tr>
<tr>
<td>Node nextWaiter</td>
<td>条件队列中的后续节点，如果当前节点是共享的，那么这个字段将是一个SHARED变量，也就是说节点类型和条件队列中的后续节点共用同一个字段</td>
</tr>
<tr>
<td>LockSupport void park()</td>
<td>阻塞当前线程，如果调用unpark方法或者当前线程被中断，才能从park方法返回</td>
</tr>
<tr>
<td>LockSupport void unpark(Thread thread)</td>
<td>唤醒处于阻塞状态的线程</td>
</tr>
<tr>
<td>ConditionObject Node firstWaiter</td>
<td>条件队列首节点</td>
</tr>
<tr>
<td>ConditionObject Node lastWaiter</td>
<td>条件队列尾节点</td>
</tr>
<tr>
<td>void await()</td>
<td>当前线程进入等待状态直到signal或中断，当前线程将进入运行状态且从await方法返回的情况，包括：其他线程调用该Condition的signal或者signalAll方法，且当前线程被选中唤醒；其他线程调用interrupt方法中断当前线程；如果当前线程从await方法返回表明该现层已经获取了Condition对象对应的锁</td>
</tr>
<tr>
<td>void awaitUninterruptibly()</td>
<td>和await方法类似，但是中断不敏感</td>
</tr>
<tr>
<td>long awaitNanos(long nanosTimeout)</td>
<td>当前线程进入等待状态直到被signal、中断或者超时。返回值表示剩余的时间。</td>
</tr>
<tr>
<td>boolean awaitUntil(Date deadline)</td>
<td>当前线程进入等待状态直到被signal、中断或者某个时间。如果没有到指定时间就被通知，方法返回true，否则表示到了指定时间，返回false</td>
</tr>
<tr>
<td>void signal()</td>
<td>唤醒一个等待在Condition上的线程，该线程从等待方法返回前必须获得与Condition相关联的锁</td>
</tr>
<tr>
<td>void signalAll()</td>
<td>唤醒所有等待在Condition上的线程，能够从等待方法返回的线程必须获得与Condition相关联的锁</td>
</tr>
</tbody>
</table>
<h3 id="AQS的源代码实现"><a href="#AQS的源代码实现" class="headerlink" title="AQS的源代码实现"></a>AQS的源代码实现</h3><p>主要通过独占式同步状态的获取和释放、共享式同步状态的获取和释放。</p>
<h4 id="独占式同步状态的获取和释放"><a href="#独占式同步状态的获取和释放" class="headerlink" title="独占式同步状态的获取和释放"></a>独占式同步状态的获取和释放</h4><p>独占式同步状态调用的方法是acquire，代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>( !tryAcquire(arg) &amp;&amp; acquireQueued( addWaiter( Node.EXCLUSIVE ), arg ) )</span><br><span class="line">    	selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码主要完成了同步状态获取、节点构造、加入同步队列以及在同步队列中自旋等待的相关工作，其主要逻辑是：首先调用子类实现的tryAcquire方法，该方法保证线程安全的获取同步状态，如果同步状态获取失败，则构造独占式同步节点（同一时刻只能有一个线程成功获取同步状态）并通过addWaiter方法将该节点加入到同步队列的尾部，最后调用acquireQueued方法，使得该节点以自旋的方式获取同步状态。如果获取不到则阻塞节点中的线程，而被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现。</p>
<p>下面来首先看下节点构造和加入同步队列是如何实现的。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//当前线程构造成Node节点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">//尝试快速在尾节点后新增节点提升算法效率 先将尾节点指向pred</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span>(pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">    	<span class="comment">//尾节点不为空 当前线程节点的前驱节点指向尾节点</span></span><br><span class="line">        Node.prev = pred;</span><br><span class="line">        <span class="comment">//并发处理 尾节点有可能已经不是之前的节点，所以需要CAS更新</span></span><br><span class="line">        <span class="keyword">if</span>( compareAndSetTail(pred, node) ) &#123;</span><br><span class="line">        	<span class="comment">//CAS更新成功 当前线程为尾节点 原先尾节点的后续节点就是当前节点</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第一个入队的节点或者是尾节点后续节点新增失败时进入enq</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    	Node t = tail;</span><br><span class="line">        <span class="keyword">if</span>( t == <span class="keyword">null</span> ) &#123;</span><br><span class="line">        	<span class="comment">//尾节点为空 第一次入队 设置头尾节点一致 同步队列的初始化</span></span><br><span class="line">            <span class="keyword">if</span>(compareAndSetHead( <span class="keyword">new</span> Node() )) &#123;</span><br><span class="line">            	tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="comment">//所有线程节点在构造完第一个节点后 依次加入到同步队列中</span></span><br><span class="line">            	node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> ( compareAndSetTail(t, node) ) &#123;</span><br><span class="line">                	t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>节点进入同步队列之后，就进入了一个自旋的过程，每个线程节点都在自省地观察，当条件满足，获取到了同步状态，就可以从这个自旋过程中退出，否则依旧留在这个自旋过程中并会阻塞节点的线程，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">    	<span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        	<span class="comment">//获取当前线程节点的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//前驱节点为头节点且成功获取同步状态</span></span><br><span class="line">            <span class="keyword">if</span>( p == head &amp;&amp; tryAcquire(arg) ) &#123;</span><br><span class="line">            	<span class="comment">//设置当前节点为头节点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">//help GC</span></span><br><span class="line">                p.next = <span class="keyword">null</span>;</span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//是否阻塞</span></span><br><span class="line">            <span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node)  &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">            	interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(failed) &#123;</span><br><span class="line">        	cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再来看看shouldParkAfterFailedAcquire和parkAndCheckInterrupt是怎么来阻塞当前线程的，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//前驱节点的状态决定后续节点的行为</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span>(ws = Node.SIGNAL) &#123;</span><br><span class="line">    	<span class="comment">//前驱节点为-1，后续节点可以被阻塞</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="keyword">do</span>&#123;</span><br><span class="line">        	node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> ( pred.waitStatus &gt; <span class="number">0</span> );</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">//当前节点是初始或者共享状态就设置为-1，使后续节点阻塞</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//阻塞线程</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当同步状态获取成功之后，当前线程从acquire方法返回，对于锁这种并发组建而言，就意味着当前线程获取了锁。有获取同步状态的方法，就存在其对应的释放方法，该方法为release，现在来看下这个方法的实现，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 同步状态释放成功</span></span><br><span class="line">	<span class="keyword">if</span>( tryReleas(arg) ) &#123;</span><br><span class="line">    	Node h = head;</span><br><span class="line">        <span class="keyword">if</span>( h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span> ) &#123;</span><br><span class="line">        	<span class="comment">//直接释放头节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">( Node node )</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span>(ws &lt; <span class="number">0</span>)</span><br><span class="line">    	compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//寻找符合条件的后续节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    	s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(Node t = tail; t!= <span class="keyword">null</span> &amp;&amp; t!= node; t=t.prev)</span><br><span class="line">        	<span class="keyword">if</span>(t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">            	s=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s!=<span class="keyword">null</span>)</span><br><span class="line">    	<span class="comment">//唤醒后续节点</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>独占式释放四非常简单而且明确的。</p>
<p>总结：在获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋；移出队列的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用tryRelease方法释放同步状态，然后唤醒头节点的后继节点。</p>
<h4 id="共享式同步状态的获取和释放"><a href="#共享式同步状态的获取和释放" class="headerlink" title="共享式同步状态的获取和释放"></a>共享式同步状态的获取和释放</h4><p>共享式同步状态调用的方法是acquireShared，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获取同步状态的返回值大于等于0时表示可以获取同步状态</span></span><br><span class="line">    <span class="comment">//小于0表示可以获取步到同步状态，需要进入队列等待</span></span><br><span class="line">    <span class="keyword">if</span>(tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">    	doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//独占式一样的入队操作</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">    	<span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//自旋</span></span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        	<span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span>(p == head) &#123;</span><br><span class="line">            	<span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span>(r &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                	<span class="comment">//前驱节点为头节点且成功获取同步状态 可退出自旋</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (interrupted) </span><br><span class="line">                    	selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">            interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(failed)</span><br><span class="line">        	cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">	Node h = head;</span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="keyword">if</span>(propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    	Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.isShared()) &#123;</span><br><span class="line">        	doReleaseShared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>共享式获取也需要释放同步状态<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//释放同步状态</span></span><br><span class="line">    <span class="keyword">if</span>(tryReleaseShared(arg)) &#123;</span><br><span class="line">    	<span class="comment">//唤醒后续等待的节点</span></span><br><span class="line">        doRleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    	Node h = head;</span><br><span class="line">        <span class="keyword">if</span>(h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">        	<span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span>(ws == Node.SIGNAL) &#123;</span><br><span class="line">            	<span class="keyword">if</span>(!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                	<span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//唤醒后续节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ws == <span class="number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="number">0</span>, NodePROPAGATE))</span><br><span class="line">            	<span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(h == head) </span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2019/06/18/Java并发之AQS详解/" data-id="cj49du1qo000nl4udauxi5num" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java并发工具类之LongAdder" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2019/06/17/Java并发工具类之LongAdder/" class="article-date">
  <time datetime="2019-06-17T14:28:40.000Z" itemprop="datePublished">2019-06-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2019/06/17/Java并发工具类之LongAdder/">Java并发工具类之LongAdder</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>LongAdder是Java8新出的工具类，个人认为是一个以牺牲空间换取性能的工具。<br><img src="/lfhboke.github.io/css/images/atomiclong.PNG" alt="AtomicLong"><br>下面是LongAdder<br><img src="/lfhboke.github.io/css/images/longadder.PNG" alt="LongAdder"><br>是将一个变量进一步拆分到一个base数组中，减少资源竞争<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cell</span></span>&#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">    Cell(<span class="keyword">long</span> x) &#123;</span><br><span class="line">    	value = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">cas</span><span class="params">(<span class="keyword">long</span> cmp, <span class="keyword">long</span> val)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, valueOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123; </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">      	UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; ak = Cell.class;</span><br><span class="line">        valueOffset = UNSAFE.objectFieldOffset(ak.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">      &#125; <span class="keyword">catch</span>( Exception e ) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>类似于AtomicLong，利用CAS来更新变量</li>
<li>@Contended避免value伪共享</li>
</ol>
<p>将多个cell数组中的值加起来的和就类似于AtomicLong中的value<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Cell[] as = cells;</span><br><span class="line">    Cell a;</span><br><span class="line">    <span class="keyword">long</span> sum = base;</span><br><span class="line">    <span class="keyword">if</span> ( as != <span class="keyword">null</span> ) &#123;</span><br><span class="line">    	<span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i ) &#123;</span><br><span class="line">        	<span class="keyword">if</span> ( ( a = as[i] != <span class="keyword">null</span> ) ) &#123;</span><br><span class="line">            	sum += a.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>increment()的调用链<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.atomic.LongAdder.increment</span><br><span class="line">-&gt;java.util.concurrent.atomic.LongAdder.add</span><br></pre></td></tr></table></figure></p>
<p><img src="/lfhboke.github.io/css/images/threadprocess.PNG" alt="ThreadProcess"><br>add()方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">	Cell[] as; </span><br><span class="line">    <span class="keyword">long</span> b, v;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    Cell a;</span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> || !casBase(b = base, b+x)) &#123;</span><br><span class="line">    	<span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> ( as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> || (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> || !(uncontended = a.cas( v = a.value, v+x )) ) &#123;</span><br><span class="line">        	longAccumulate(x, <span class="keyword">null</span>, uncontended);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一次Cell数组为空，进入casBase()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">casBase</span><span class="params">(<span class="keyword">long</span> cmp, <span class="keyword">long</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, BASE, cmp, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>即原子更新，成功则直接返回，失败则说明出现并发了if的三个判断</p>
<ol>
<li>数组为空</li>
<li>或者数组长度小于1</li>
<li>或者位置上没有Cell对象，即getProbe()&amp;m其实相当于hashMap里面的tab[i=(n-1)&amp;hash]</li>
<li>或者修改cell的值失败<br>才会最终进入到longAccumulate()方法中<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5></li>
<li>如果Cells表为空，尝试用CAS更新base字段，成功则退出；</li>
<li>如果Cells表为空，CAS更新base字段失败，出现竞争，uncontend为true，调用longAccumulate；</li>
<li>如果Cells表非空，且前线程映射的槽非空，CAS更新Cell的值，成功则返回，否则，uncontended设为false，调用longAccumulate。</li>
</ol>
<p>制约AtomicLong高效的原因是高并发，高并发意味着CAS的失败几率更高，重试次数更多，越多线程重试，CAS失败几率又越高，AtomicLong效率降低。LongAdder通过减少并发，将单一value的更新压力分担到多个value中去，降低单个value的“热度”，分段更新。</p>
<p>这样，线程数再多也会分担到多个value上去更新，只需要增加value就可以降低value的“热度”。cells就是这个“段”cell中的value就是存放更新值。</p>
<p>caseBase操作等价于AtomicLong中的CAS操作，要知道，LongAdder这样的处理方式是有坏处的，分段操作必然带来空间上的浪费，可以空间换时间。</p>
<p>caseBase操作保证了在低并发时，不会立即进入分支做分段更新操作，因为低并发时，caseBase操作基本都会成功，只有并发高到一定程度了，才会进入分支。</p>
<p>longAccumulate()方法如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">longAccumulate</span><span class="params">(<span class="keyword">long</span> x, LongBinaryOperator fn, <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">    	ThreadLocalRandom.current();</span><br><span class="line">        h = getProbe();</span><br><span class="line">        wasUncontended = <span class="keyword">true</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    	Cell[] as; Cell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">        <span class="keyword">if</span>((as = cells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="keyword">if</span> ( (a = as[(n-<span class="number">1</span>)&amp;h]) == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            	<span class="keyword">if</span>(cellsBusy == <span class="number">0</span>) &#123;</span><br><span class="line">                </span><br><span class="line"> 	Cell r = <span class="keyword">new</span> Cell(x);</span><br><span class="line">    <span class="keyword">if</span>(cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">    	<span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">        	Cell[] rs;<span class="keyword">int</span> m, j;</span><br><span class="line">            <span class="keyword">if</span>((rs = cells) != <span class="keyword">null</span> &amp;&amp; (m = rs.length) &gt; <span class="number">0</span> &amp;&amp; rs[j = (m - <span class="number">1</span>)&amp;h] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            	rs[j] = r;</span><br><span class="line">                created = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        	cellsBusy = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(created)</span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    collide = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!wasUncontended)</span><br><span class="line">            	wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a.cas(v = a.value, ((fn == <span class="keyword">null</span>) ?v+x: fn.applyAsLong(v, x))))</span><br><span class="line">            	<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">            	</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>如果Cells表为空，尝试获取锁之后初始化表（初始大小为2）；</li>
<li>如果Cells表非空，对应的Cell为空，自旋锁未被占用，尝试获取锁，添加新的Cell；</li>
<li>如果Cells表非空，找到线程对应的Cell，尝试通过CAS更新该值；</li>
<li>如果Cells表非空，线程对应的Cell CAS更新失败，说明存在竞争，尝试获取自旋锁之后扩容，将cells数组扩大，降低每个cell的并发量后再试</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2019/06/17/Java并发工具类之LongAdder/" data-id="cj49du1ns0004l4udy413f6v6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-redis之LRU算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2019/05/22/redis之LRU算法/" class="article-date">
  <time datetime="2019-05-22T05:07:32.000Z" itemprop="datePublished">2019-05-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2019/05/22/redis之LRU算法/">redis之LRU算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>以前其实有看过redis的超出物理内存限制时的淘汰策略，但没有深入的分析过，这次做个笔记。</p>
<p>当redis内存超出物理内存限制时，内存的数据会开始和磁盘产生频繁的交换。</p>
<p>为了限制最大使用内存，redis提供了配置参数maxmemory来限制内存超出期望大小。</p>
<p>当内存超出maxmemory时，redis提供了几种可选策略（maxmemory-policy）：</p>
<ol>
<li>noiviction：不会继续服务写请求（del请求可以继续服务），读请求可以继续进行。这样可以保证不会丢失数据，但是会让线上的业务不能持续进行。这时默认淘汰策略。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2019/05/22/redis之LRU算法/" data-id="cj49du1oj000dl4udq2chts2b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java8新特性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2019/05/22/java8新特性/" class="article-date">
  <time datetime="2019-05-21T23:31:21.000Z" itemprop="datePublished">2019-05-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2019/05/22/java8新特性/">java8新特性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>Lambda表达式。</li>
<li>接口的默认方法与静态方法：在接口中定义默认方法，使用default关键字，并提供默认的实现。</li>
<li><p>方法引用：</p>
<p> 通常与Lambda表达式联合使用，可以直接引用已有Java类或对象的方法。一般有四种不同的方法引用：</p>
<ol>
<li>构造器引用。语法式Class::new，或者更一般的Class<t>::new，要求构造器方法是没有参数；</t></li>
<li>静态方法引用。语法是Class::static_method，要求接受一个Class类型的参数；</li>
<li>特定类的任意对象方法引用。它的语法是Class::method。要求方法没有参数的；</li>
<li>特定对象的方法引用，它的语法是instance::method。要求方法接受一个参数，与3不同的地方在于，3是在列表元素上分别调用方法，而4是在某个对象上调用方法，将列表元素作为参数传入；</li>
</ol>
</li>
<li><p>重复注解：在Java5中使用注解有一个限制，即相同的注解在同一位置只能声明一次。Java8引入重复注解，这样相同的注解在同一地方也可以声明多次。重复注解机制本身需要用@Repeatable注解。Java8在编译器层做了优化，相同注解会以集合的方式保存，因此底层的原理并没有变化。</p>
</li>
<li>扩展注解的支持：Java8扩展了注解的上下文，几乎可以为任何东西添加注解，包括局部变量、泛型类、父类与接口的实现，连方法的异常也能添加注解。</li>
<li>Optional：Java8引入Optional类来防止空指针异常，Optional类实际上是个容器：它可以保存类型T的值，或者保存null。使用Optional类我们就不用显式进行空指针检查了。</li>
<li>Stream：Stream API是把真正的函数式编程风格引入到Java中。起始简单来说可以把Stream理解为MapReduce，其实是一连串支持连续、并行聚集操作的元素。从语法上看，也很像Linux的管道、或者链式编程，代码写起来简洁明了。</li>
<li>Date/TimeAPI：Java8新的Date-TimeAPI受Joda-Time的影响，提供了新的java.time包，可以用来替代java.util.Date和java.util.Calendar。一般会用到Clock、LocaleDate、LocalTime、LocaleDateTime、ZonedDateTime、Duration这些类，对于时间日期的改进还是非常不错的。</li>
<li>JavaScript引擎Nashorn：Nashorn允许在JVM上开发运行JavaScript应用，允许java与JavaScript相互调用。</li>
<li>Base64：在Java8中，Base64编码成为了Java类库的标准。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2019/05/22/java8新特性/" data-id="cj49du1o50009l4udpv8578de" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-流计算框架之storm（基础篇）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2019/03/01/流计算框架之storm（基础篇）/" class="article-date">
  <time datetime="2019-03-01T01:59:10.000Z" itemprop="datePublished">2019-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2019/03/01/流计算框架之storm（基础篇）/">流计算框架之storm（基础篇）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Storm是一个分布式的、高容错的实时计算系统。</p>
<p>Storm对于实时计算的意义相当于Hadoop对于批处理的意义。Hadoop提供了Map和Reduce。同样，Storm也对数据的实时计算提供了Spout和Bolt。</p>
<p>Storm使用场景：</p>
<ol>
<li>流数据处理：Storm可以用来处理源源不断的消息，并将处理之后的结果保存到持久化介质中。</li>
<li>分布式RPC：由于Storm的处理组建都是分布式的，而且处理延迟都极低，所以Storm可以做为一个通用的分布式RPC框架来使用。<h3 id="一个Storm集群的基本组件"><a href="#一个Storm集群的基本组件" class="headerlink" title="一个Storm集群的基本组件"></a>一个Storm集群的基本组件</h3></li>
</ol>
<p>storm上面运行的是Topology。一个Topology永远运行（除非你显式的杀掉）。</p>
<p>在Storm的集群里面有两种节点：控制节点（master node）和工作节点（worker node）。控制节点上面运行一个后台程序：Nimbus，它负责在集群里面分布代码，分配工作给机器，并且监控状态。每一个工作节点上面运行要给叫做Supervisor的节点（类似TaskTracker）。Supervisor会监听分配给它那台机器的工作，根据需要启动/关闭工作进程。每一个工作进程执行一个Topology（类似Job）的一个子集；一个运行的Topology由运行在很多机器上的很多工作进程Worker（类似Child）组成。<br><img src="/lfhboke.github.io/css/images/storm1.png" alt="storm toplogy结构"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2019/03/01/流计算框架之storm（基础篇）/" data-id="cj49du1on000fl4udjdk4bt6g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-消息中间件之kafka-原理篇" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2018/10/13/消息中间件之kafka-原理篇/" class="article-date">
  <time datetime="2018-10-13T13:53:53.000Z" itemprop="datePublished">2018-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2018/10/13/消息中间件之kafka-原理篇/">消息中间件之kafka(原理篇)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="kafka架构"><a href="#kafka架构" class="headerlink" title="kafka架构"></a>kafka架构</h3><p><img src="/lfhboke.github.io/css/images/kafka1.png" alt="kafka拓扑结构"><br>图中概念定义如下：</p>
<ol>
<li>producer：消息生产者。</li>
<li>broker：集群包含的服务器。</li>
<li>topic：每条发布到集群的消息类别，概念篇里没说明这边补一下，kafka是面向topic的。</li>
<li>partition：每个topic包含一个或多个partition。kafka的分配单元。</li>
<li>consumer：从kafka集群中消费消息的终端或服务。</li>
<li>Consumer group：high-level consumer API中，每个consumer都属于一个consumer group，每条消息只能被consumer group中的一个Consumer消费，但可以被多个consumer group消费。</li>
<li>replica：partition的副本，保障partition的高可用。</li>
<li>leader： replica中的一个角色，producer和consumer只跟leader交互。</li>
<li>follower：replica中的一个角色，从leader中复制数据。</li>
<li>controller：kafka集群中的其中一个服务器，用来进行leader election以及各种failover。</li>
<li>zookeeper：kafka通过zookeeper来存储集群的meta信息。<h4 id="zookeeper节点中kafka存储结构"><a href="#zookeeper节点中kafka存储结构" class="headerlink" title="zookeeper节点中kafka存储结构"></a>zookeeper节点中kafka存储结构</h4></li>
</ol>
<p><img src="/lfhboke.github.io/css/images/zookeeper1.jpg" alt="kafka在zookeeper中存储结构"></p>
<h3 id="producer发布消息"><a href="#producer发布消息" class="headerlink" title="producer发布消息"></a>producer发布消息</h3><h4 id="写入方式"><a href="#写入方式" class="headerlink" title="写入方式"></a>写入方式</h4><p>producer采用push模式将消息发布到broker，每条消息都被append到patition中，属于顺序写磁盘（顺序写磁盘效率比随机写内存要高，保障kafka吞吐率）。</p>
<h4 id="消息路由"><a href="#消息路由" class="headerlink" title="消息路由"></a>消息路由</h4><p>producer发送消息到broker时，会根据分区算法选择将其存储到哪一个partition。其路由机制为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指定了partition，则直接使用；</span><br><span class="line">未指定partition但指定key，通过对key的value进行<span class="built_in">hash</span>选出一个partition；</span><br><span class="line">partition和key都未指定，使用轮询选出一个partition。</span><br></pre></td></tr></table></figure></p>
<p>然后看一段java客户端分区源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建消息实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProducerRecord</span><span class="params">(String topic, Integer partition, Long timestamp, K key, V value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(topic == <span class="keyword">null</span>)&#123;</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Topic cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(timestamp != <span class="keyword">null</span> &amp;&amp; timestamp &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid timestamp"</span> + timestamp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.topic = topic;</span><br><span class="line">    <span class="keyword">this</span>.partition = partition;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.timestamp = timestamp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算partition，如果指定了partition则直接使用，否则使用key计算</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(ProducerRecord&lt;K, V&gt; record, <span class="keyword">byte</span>[] serializedKey, <span class="keyword">byte</span>[] serializedValue, Cluster cluster)</span> </span>&#123;</span><br><span class="line">	Integer partition = record.partition();</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> != partition) &#123;</span><br><span class="line">    	List&lt;Partitioninfo&gt; partitions = cluster.partitionsforTopic(record.topic());</span><br><span class="line">        <span class="keyword">int</span> lastPartition = partitions.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(partition &lt; <span class="number">0</span> || partition &gt; lastPartition) &#123;</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> partition;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.partitioner.partition(record.topic(), record.key(), serializedKey, record.value(), serializedValue, cluster);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用key选取partition</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes, Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster)</span> </span>&#123;</span><br><span class="line">	List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line">    <span class="keyword">int</span> numPartitions = partitions.size();</span><br><span class="line">    <span class="keyword">if</span>(keyBytes == <span class="keyword">null</span>)&#123;</span><br><span class="line">    	<span class="keyword">int</span> nextValue = counter.getAndIncrement();</span><br><span class="line">        List&lt;PartitionInfo&gt; availablePartitions = cluster.availablePartitionsForTopic(topic);</span><br><span class="line">        <span class="keyword">if</span>(availablePartitions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="keyword">int</span> part = DefaultPartitioner.toPositive(nextValue) % availablePartitions.size();</span><br><span class="line">            <span class="keyword">return</span> availablePartitions.get(part).partition();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="keyword">return</span> DefaultPartitioner.toPositive(nextValue) % numPartitions;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">//对keyBytes进行hash选出partition</span></span><br><span class="line">        <span class="keyword">return</span> DefaultPartitioner.toPositive(Utils.murmur2(keyBytes)) % numPartittions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="写入流程"><a href="#写入流程" class="headerlink" title="写入流程"></a>写入流程</h4><p>producer写入消息序列图如下：<br><img src="/lfhboke.github.io/css/images/kafka2.jpg" alt="kafka producer写入消息序列图"></p>
<ol>
<li>producer先从zookeeper的”/brokers/…/state”节点找到该partition的leader</li>
<li>producer将消息发送给该leader</li>
<li>leader将消息写入本地log</li>
<li>followers从leader pull消息，写入本地log后leader发送ACK</li>
<li>leader收到所有ISR中的replica的ACK后，增加HW（high watermark，最后commit的offset）并向producer发送ACK<h4 id="producer-delivery-guarantee"><a href="#producer-delivery-guarantee" class="headerlink" title="producer delivery guarantee"></a>producer delivery guarantee</h4></li>
</ol>
<p>一般情况下存在三种情况：</p>
<ol>
<li>At most once消息可能会丢，但绝不会重复传输</li>
<li>At least one消息绝不会，但可能会重复传输</li>
<li>Exactly once每条消息肯定会被传输一次且仅传输一次<h3 id="broker保存消息"><a href="#broker保存消息" class="headerlink" title="broker保存消息"></a>broker保存消息</h3><h4 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h4></li>
</ol>
<p>物理上把topic分成一个或多个partition（对应server.properties中的num.partitions=3配置），每个partition物理上对应一个文件夹（该文件夹存储该partition的所有消息和索引文件）。</p>
<h4 id="存储策略"><a href="#存储策略" class="headerlink" title="存储策略"></a>存储策略</h4><p>无论消息是否被消费，kafka都会保留所有消息。有两种策略可以删除旧数据：</p>
<ol>
<li>基于时间：log.retention.hours = 168</li>
<li>基于大小：log.retention.bytes = 1073741824</li>
</ol>
<p>需要注意的是，因为Kafka读取特定消息的时间复杂度为O(1)，即与文件大小无关，所以这里删除过期文件与提高kafka性能无关。</p>
<h4 id="topic创建与删除"><a href="#topic创建与删除" class="headerlink" title="topic创建与删除"></a>topic创建与删除</h4><h5 id="创建topic"><a href="#创建topic" class="headerlink" title="创建topic"></a>创建topic</h5><p>创建topic的序列图如下所示：<br><img src="/lfhboke.github.io/css/images/kafka3.jpg" alt="kafka producer写入消息序列图"></p>
<ol>
<li>controller在Zookeeper的/brokers/topics节点上注册watcher，当topic被创建，则controller会通过watch得到该topic的partition/replica分配。</li>
<li><p>controller从/brokers/ids读取当前所有可用的broker列表，对于set_p中的每个partition：</p>
<p> 从分配给该partition的所有replica中任选一个可用的broker作为新的leader，并将AR设置为新的ISR</p>
<p> 将新的leader和ISR写入/brokers/topics/[topic]/partitions/[partition]/state</p>
</li>
<li>controller通过RPC向相关的broker发送LeaderAndISRRequest。<h5 id="删除topic"><a href="#删除topic" class="headerlink" title="删除topic"></a>删除topic</h5></li>
<li>controller在zookeeper的/brokers/topic节点上注册watcher，当topic被删除，则controller会通过watch得到该topic的partition/replica分配。</li>
<li>若delete.topic.enable=false，结束；否则controller注册在/admin/delete_topics上的watch被fire，controller通过回调向对应的broker发送StopreplicaRequest。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2018/10/13/消息中间件之kafka-原理篇/" data-id="cj49du1ot000hl4udq65jnp6e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-消息中间件之kafka-基础篇" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2018/10/13/消息中间件之kafka-基础篇/" class="article-date">
  <time datetime="2018-10-13T13:21:22.000Z" itemprop="datePublished">2018-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2018/10/13/消息中间件之kafka-基础篇/">消息中间件之kafka(基础篇)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前已经分析了activeMq，现在开始学习kafka。</p>
<p>kafka也是消息中间件，但不同的是，它类似于JMS特性，但并不是JMS规范的实现。</p>
<p>kafka对消息保存时根据Topic进行归类，发送消息者成为Producer，消息接受者成为Consumer，此外kafka集群有多个kafka实例组成，每个实例（server）成为broker。无论是kafka集群，还是producer和consumer都依赖于zookeeper保证系统可用性。kafka是天生的分布式消息，多用于实时性较高的消息消费。</p>
<h3 id="kafka-java-api"><a href="#kafka-java-api" class="headerlink" title="kafka java api"></a>kafka java api</h3><p>多说无益，直接上代码实际：</p>
<h4 id="producer源码"><a href="#producer源码" class="headerlink" title="producer源码"></a>producer源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"192.168.1.110:9092"</span>);</span><br><span class="line">        properties.put(<span class="string">"acks"</span>, <span class="string">"all"</span>);</span><br><span class="line">        properties.put(<span class="string">"retries"</span>, <span class="number">0</span>);</span><br><span class="line">        properties.put(<span class="string">"batch.size"</span>, <span class="number">16384</span>);</span><br><span class="line">        properties.put(<span class="string">"linger.ms"</span>, <span class="number">1</span>);</span><br><span class="line">        properties.put(<span class="string">"buffer.memory"</span>, <span class="number">33554432</span>);</span><br><span class="line">        properties.put(<span class="string">"key.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">        properties.put(<span class="string">"value.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">        Producer&lt;String, String&gt; producer = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            producer = <span class="keyword">new</span> KafkaProducer&lt;String, String&gt;(properties);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                String msg = <span class="string">"Message "</span> + i;</span><br><span class="line">                producer.send(<span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(<span class="string">"HelloWorld"</span>, msg));</span><br><span class="line">                System.out.println(<span class="string">"Sent:"</span> + msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            producer.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Consumer源码"><a href="#Consumer源码" class="headerlink" title="Consumer源码"></a>Consumer源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"192.168.1.110:9092"</span>);</span><br><span class="line">        properties.put(<span class="string">"group.id"</span>, <span class="string">"group-1"</span>);</span><br><span class="line">        properties.put(<span class="string">"enable.auto.commit"</span>, <span class="string">"true"</span>);</span><br><span class="line">        properties.put(<span class="string">"auto.commit.interval.ms"</span>, <span class="string">"1000"</span>);</span><br><span class="line">        properties.put(<span class="string">"auto.offset.reset"</span>, <span class="string">"earliest"</span>);</span><br><span class="line">        properties.put(<span class="string">"session.timeout.ms"</span>, <span class="string">"30000"</span>);</span><br><span class="line">        properties.put(<span class="string">"key.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">        properties.put(<span class="string">"value.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line"></span><br><span class="line">        KafkaConsumer&lt;String, String&gt; kafkaConsumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(properties);</span><br><span class="line">        kafkaConsumer.subscribe(Arrays.asList(<span class="string">"HelloWorld"</span>));</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = kafkaConsumer.poll(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"offset = %d, value = %s"</span>, record.offset(), record.value());</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2018/10/13/消息中间件之kafka-基础篇/" data-id="cj49du1ox000jl4uduecctxw1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Mybatis之SqlSession四大对象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2017/09/14/Mybatis之SqlSession四大对象/" class="article-date">
  <time datetime="2017-09-14T11:04:58.000Z" itemprop="datePublished">2017-09-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2017/09/14/Mybatis之SqlSession四大对象/">Mybatis之SqlSession四大对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之所以分析SqlSession四大对象，其实是为了后续讲解Mybatis插件作为铺垫。</p>
<p>Mybatis插件其实就是拦截SqlSession的四大对象，进行其中属性的修改。</p>
<p>SqlSession给出了删除、更新、插入、选择等方法。</p>
<p>其中四大对象包括：</p>
<ol>
<li><font color="red">Executor</font>：执行器，由它来调度StatementHandler、ParameterHandler、ResultHandler等来执行对应的SQL。</li>
<li><font color="red">StatementHandler</font>：使用数据库的Statement(PreparedStatement)执行操作，它是四大对象的核心，起到承上启下的作用。</li>
<li><font color="red">ParameterHandler</font>：SQL对参数的处理。</li>
<li><font color="red">ResultHandler</font>：进行最后数据集（ResultSet）的封装返回处理。<h3 id="执行器（Executor）"><a href="#执行器（Executor）" class="headerlink" title="执行器（Executor）"></a>执行器（Executor）</h3></li>
</ol>
<p>执行器（Executor）是一个真正执行Java和数据库交互的东西。在Mybatis中存在三种执行器：</p>
<ol>
<li>SIMPLE，简易执行器，默认执行器。</li>
<li>REUSE，执行器重用预处理器。</li>
<li>BATCH，执行器重用语句和批量更新，它是针对批量专用的执行器。</li>
</ol>
<p>创建Executor：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">	executorType = executorType == <span class="keyword">null</span>? defaultExecutorType: executorType;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span>? ExecutorType.SIMPLE: executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="keyword">if</span>(ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">    	executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">    	executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cacheEnabled) &#123;</span><br><span class="line">    	executor = <span class="keyword">new</span> CacheingExecutor(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SimpleExecutor源码分析;<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleExecutor</span> <span class="keyword">extends</span> <span class="title">BaseExecutor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>&lt;E&gt; List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    	Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">        	Configuration configuration = ms.getConfiguration();</span><br><span class="line">            StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">            stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">            stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">            <span class="keyword">return</span> handler.&lt;E&gt;query(stmt, resultHandler);</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        	closeStatement(stmt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    	Statement stmt;</span><br><span class="line">        Connection connection = getConnection(statementLog);</span><br><span class="line">        stmt = handler.prepare(connection);</span><br><span class="line">        handler.parameterize(stmt);</span><br><span class="line">        <span class="keyword">return</span> stmt;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="数据库会话器（StatementHandler）"><a href="#数据库会话器（StatementHandler）" class="headerlink" title="数据库会话器（StatementHandler）"></a>数据库会话器（StatementHandler）</h3><p>生成会话器的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHander, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">	StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">    statementHandler = (StatementHandler) intercptorChain.pluginAll(statementHandler);</span><br><span class="line">    <span class="keyword">return</span> statementHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建的真实对象是一个RoutingStatementHandler对象，它实现了接口StatementHandler。</p>
<p>看下RoutingStatementHandler的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoutingStatementHandler</span> <span class="keyword">implements</span> <span class="title">StatementHandler</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> StatementHandler delegate;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RoutingStatementHandler</span><span class="params">(Executor executor, MappedStatement ms, Object parameter, RowBouds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">switch</span>(ms.getStatementType()) &#123;</span><br><span class="line">        	<span class="keyword">case</span> STATEMENT:</span><br><span class="line">            	delegate = <span class="keyword">new</span> SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler,boundSql);</span><br><span class="line">               	<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PREPARED:</span><br><span class="line">            	delegate = <span class="keyword">new</span> PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CALLABLE:</span><br><span class="line">            	delegate = <span class="keyword">new</span> CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            	<span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PreparedStatementHandler源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseStatementHandler</span> <span class="keyword">implements</span> <span class="title">StatementHandler</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Statement <span class="title">prepare</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    	ErrorContext.instance().sql(boundSql.getSql());</span><br><span class="line">        Statement statement = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">        	statement = instantiateStatement(connection);</span><br><span class="line">            setStatementTimeOut(statement);</span><br><span class="line">            setFetchSize(statement);</span><br><span class="line">            <span class="keyword">return</span> statement;</span><br><span class="line">        &#125;<span class="keyword">catch</span>()&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Executor调用parameterize()方法去设置参数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parameterize</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">	parameterHandler.setParameters((PreparedStatement) statement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>StatementHandler的查询方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>&lt;E&gt; List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">	PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">    ps.execute();</span><br><span class="line">    <span class="keyword">return</span> resultSetHandler.&lt;E&gt;handleResultSets(ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于在执行前参数和SQL都被prepare()方法预编译，参数在parameterize()方法上已经进行了设置。</p>
<p>现在描述一下查询SQL的执行过程：</p>
<p>Excutor会先调用StatementHandler的prepare()方法预编译SQL语句，同时设置一些基本运行的参数。然后用parameterize()方法启用ParameterHandler设置参数，完成预编译，跟着就是执行查询。</p>
<h3 id="参数处理器"><a href="#参数处理器" class="headerlink" title="参数处理器"></a>参数处理器</h3><p>首先看下ParameterHandler定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ParameterHandler</span> </span>&#123;</span><br><span class="line">	<span class="function">Object <span class="title">getParameterObject</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中，getParameterObject()方法的作用是返回参数对象，setParameters()方法的作用是设置预编译SQL语句的参数。<br>Mybatis为ParameterHandler提供了一个实现类DefaultParameterHandler：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eduardo Macarron</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultParameterHandler</span> <span class="keyword">implements</span> <span class="title">ParameterHandler</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TypeHandlerRegistry用map存储多种类型的TypeHandler</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TypeHandlerRegistry typeHandlerRegistry;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MappedStatement mappedStatement;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object parameterObject;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BoundSql boundSql;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Configuration configuration;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DefaultParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mappedStatement = mappedStatement;</span><br><span class="line">    <span class="keyword">this</span>.configuration = mappedStatement.getConfiguration();</span><br><span class="line">    <span class="keyword">this</span>.typeHandlerRegistry = mappedStatement.getConfiguration().getTypeHandlerRegistry();</span><br><span class="line">    <span class="keyword">this</span>.parameterObject = parameterObject;</span><br><span class="line">    <span class="keyword">this</span>.boundSql = boundSql;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getParameterObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> parameterObject;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span> </span>&#123;</span><br><span class="line">    ErrorContext.instance().activity(<span class="string">"setting parameters"</span>).object(mappedStatement.getParameterMap().getId());</span><br><span class="line">    List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">    <span class="keyword">if</span> (parameterMappings != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterMappings.size(); i++) &#123;</span><br><span class="line">        ParameterMapping parameterMapping = parameterMappings.get(i);</span><br><span class="line">        <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">          Object value;</span><br><span class="line">          String propertyName = parameterMapping.getProperty();</span><br><span class="line">          <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123; <span class="comment">// issue #448 ask first for additional params</span></span><br><span class="line">            value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            value = <span class="keyword">null</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">            value = parameterObject;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">            value = metaObject.getValue(propertyName);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 选择合适的TypeHandler实现类</span></span><br><span class="line">          TypeHandler typeHandler = parameterMapping.getTypeHandler();</span><br><span class="line">          JdbcType jdbcType = parameterMapping.getJdbcType();</span><br><span class="line">          <span class="keyword">if</span> (value == <span class="keyword">null</span> &amp;&amp; jdbcType == <span class="keyword">null</span>) &#123;</span><br><span class="line">            jdbcType = configuration.getJdbcTypeForNull();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用的是org.apache.ibatis.type.BaseTypeHandler.setParameter(PreparedStatement, int, T, JdbcType)方法</span></span><br><span class="line">            <span class="comment">// 参数下标从1开始</span></span><br><span class="line">            typeHandler.setParameter(ps, i + <span class="number">1</span>, value, jdbcType);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (TypeException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">"Could not set parameters for mapping: "</span> + parameterMapping + <span class="string">". Cause: "</span> + e, e);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">"Could not set parameters for mapping: "</span> + parameterMapping + <span class="string">". Cause: "</span> + e, e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="结果处理器（ResultSetHandler）"><a href="#结果处理器（ResultSetHandler）" class="headerlink" title="结果处理器（ResultSetHandler）"></a>结果处理器（ResultSetHandler）</h3><p>比较简单，实际上就是对返回的结果进行映射。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2017/09/14/Mybatis之SqlSession四大对象/" data-id="cj49du1q0000ll4uddzizck0c" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据库设计的三大范式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/lfhboke.github.io/2017/06/23/数据库设计的三大范式/" class="article-date">
  <time datetime="2017-06-23T03:43:42.000Z" itemprop="datePublished">2017-06-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/lfhboke.github.io/2017/06/23/数据库设计的三大范式/">数据库设计的三大范式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>什么是范式：简而言之就是，数据库设计对数据存储性能，还有开发人员对数据的操作都有莫大的关系。所以建立科学的，规范的数据库是需要满足一些规范来优化数据存储方式。</p>
<h3 id="三大范式概念"><a href="#三大范式概念" class="headerlink" title="三大范式概念"></a>三大范式概念</h3><p>第一范式：当关系模式R的所有属性都不能在分解为更基本的数据单位时，称R是满足第一范式的，简记为1NF。满足第一范式是关系模式规范化的最低要求，否则，将有很多基本操作在这样的关系模式中实现不了。<br>第二范式：如果关系模式R满足第一范式，并且R的所有非主属性都完全依赖于R的每一个候选关键属性，称R满足第二范式，简记为2NF。<br>第三范式：设R是一个满足第一范式条件的关系模式，X是R的任意属性集，如果X非传递依赖于R的任意一个候选关键字，称R满足第三范式，3NF。</p>
<h3 id="理解三大范式"><a href="#理解三大范式" class="headerlink" title="理解三大范式"></a>理解三大范式</h3><h4 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h4><ol>
<li>每一列属性都是不可再分的属性值，确保每一列的原子性</li>
<li>两列的属性相近或相似或一样，尽量合并属性一样的列，确保不产生冗余数据。</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>Name</th>
<th>Code</th>
<th>DataType</th>
<th>Length</th>
<th>Precision</th>
<th>P</th>
</tr>
</thead>
<tbody>
<tr>
<td> 1</td>
<td>留言编号</td>
<td>MsgId</td>
<td>int</td>
<td></td>
<td></td>
<td>true</td>
</tr>
<tr>
<td> 2</td>
<td>留言人姓名</td>
<td>Name</td>
<td>varchar(30)</td>
<td>30</td>
<td></td>
<td>false</td>
</tr>
<tr>
<td> 3</td>
<td>地址</td>
<td>Address</td>
<td>varchar(80)</td>
<td>80</td>
<td></td>
<td>false</td>
</tr>
</tbody>
</table>
<p> 如果需求直到那个省哪个市并按其分类，那么显然第一个表格不容易满足需求的，也不符合第一范式。</p>
<h4 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h4><p> 每一行的数据只能与其中一列相关，即一行数据只做一件事。只要数据列中出现数据重复，就要把表拆分开来。</p>
<h4 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h4><p> 数据不能存在传递关系，即每个属性都跟主键有直接关系而不是间接关系。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://linfordhu.github.io/lfhboke.github.io/2017/06/23/数据库设计的三大范式/" data-id="cj49du1ol000el4udq3uocysp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/lfhboke.github.io/page/2/">2</a><a class="page-number" href="/lfhboke.github.io/page/3/">3</a><a class="extend next" rel="next" href="/lfhboke.github.io/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/lfhboke.github.io/archives/2016/01/">January 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/lfhboke.github.io/2019/06/20/Collections解读/">Collections解读</a>
          </li>
        
          <li>
            <a href="/lfhboke.github.io/2019/06/18/Java并发之AQS详解/">Java并发之AQS详解</a>
          </li>
        
          <li>
            <a href="/lfhboke.github.io/2019/06/17/Java并发工具类之LongAdder/">Java并发工具类之LongAdder</a>
          </li>
        
          <li>
            <a href="/lfhboke.github.io/2019/05/22/redis之LRU算法/">redis之LRU算法</a>
          </li>
        
          <li>
            <a href="/lfhboke.github.io/2019/05/22/java8新特性/">java8新特性</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 lfhu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/lfhboke.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="/lfhboke.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/lfhboke.github.io/fancybox/jquery.fancybox.css">
  <script src="/lfhboke.github.io/fancybox/jquery.fancybox.pack.js"></script>


<script src="/lfhboke.github.io/js/script.js"></script>



  </div>
</body>
</html>